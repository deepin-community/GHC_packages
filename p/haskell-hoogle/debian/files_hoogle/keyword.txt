-- Hoogle documentation, generated by Hoogle
-- From http://www.haskell.org/haskellwiki/Keywords
-- See Hoogle, http://www.haskell.org/hoogle/

-- | Haskell keywords, always available
@url http://haskell.org/haskellwiki/Keywords
@package keyword

-- | Whenever a data constructor is applied, each argument to the
--   constructor is evaluated if and only if the corresponding type in the
--   algebraic datatype declaration has a strictness flag, denoted by an
--   exclamation point. For example:
--
--   <pre>
--   data STList a
--           = STCons a !(STList a)  -- the second argument to STCons will be
--                                   -- evaluated before STCons is applied
--           | STNil
--   </pre>
--
--   to illustrate the difference between strict versus lazy constructor
--   application, consider the following:
--
--   <pre>
--   stList = STCons 1 undefined
--   lzList = (:)    1 undefined
--   stHead (STCons h _) = h -- this evaluates to undefined when applied to stList
--   lzHead (h : _)      = h -- this evaluates to 1 when applied to lzList
--   </pre>
--
--   ! is also used in the "bang patterns" (GHC extension), to indicate
--   strictness in patterns:
--
--   <pre>
--   f !x !y = x + y
--   </pre>
@url #.21
@entry keyword !

-- | <ul><li>
--   Character literal: 'a'
--   </li><li>
--   Template Haskell: Name of a (value) variable or data constructor:
--   'length, 'Left
--   </li><li>
--   (in types, GHC specific) Promoted data constructor: 'True
--   </li></ul>
@url #.27
@entry keyword '

-- | <ul><li>
--   Template Haskell: Name of a type constructor or class: ''Int,
--   ''Either, ''Show
--   </li></ul>
@url #.27.27
@entry keyword ''

-- | This operator token is magic/irregular in the sense that
--
--   <pre>
--   (- 1)
--   </pre>
--
--   is parsed as the negative integer -1, rather than as an operator
--   section, as it would be for any other operator:
--
--   <pre>
--   (* 1) :: Num a => a -> a
--   </pre>
--
--   <pre>
--   (++ "foo") :: String -> String
--   It is syntactic sugar for the negate function in Prelude. See unary operator.
--   If you want the section, you can use the subtract function or (+(-1)).
--   </pre>
@url #-
@entry keyword -

-- | <pre>
--   main = print "hello world" -- this is a comment
--   --this is a comment as well
--   ---this too
--   foobar --+ this_is_the_second_argument_of_the_dash_dash_plus_operator
--   The multi-line variant for comments is {- comment -}.
--   </pre>
@url #--
@entry keyword --

-- | Arrow notation
@url #-.3C
@entry keyword -<

-- | Arrow notation
--
@url #-.3C.3C
@entry keyword -<<

-- | <ul><li>
--   The function type constructor:
--   </li></ul>
--
--   <pre>
--   length :: [a] -> Int
--   </pre>
--
--   <ul><li>
--   In lambda functions:
--   </li></ul>
--
--   <pre>
--   \x -> x + 1
--   </pre>
--
--   <ul><li>
--   To denote alternatives in case statements:
--   </li></ul>
--
--   <pre>
--   case Just 3 of
--       Nothing -> False
--       Just x  -> True
--   </pre>
--
--   <ul><li>
--   On the kind level (GHC specific):
--   </li></ul>
--
--   <pre>
--   ghci> :kind (->)
--   (->) :: * -> * -> *
--   </pre>
--
--   <ul><li>
--   Functional dependencies
--   </li></ul>
--
--   <pre>
--   -- This examples assumes that each type 'c' can "contain" only one type
--   --  i.e. type 'c' uniquely determines type 'elt'
--   class Contains c elt | c -> elt where
--      ...
--   </pre>
--
--   <ul><li>
--   View patterns
--   </li></ul>
@url #-.3E
@entry keyword ->

-- | Read as "has type":
--
--   <pre>
--   length :: [a] -> Int
--   </pre>
--
--   "Length has type list-of-'a' to Int"
--
--   Or "has kind" (GHC specific):
--
--   <pre>
--   Either :: * -> * -> *
--   </pre>
@url #::
@entry keyword ::

-- | <ul><li>
--   Statement separator in an explicit block (see layout)
--   </li></ul>
@url #.3B
@entry keyword ;

-- | <ul><li>
--   In do-notation, "draw from":
--   </li></ul>
--
--   <pre>
--   do x <- getChar
--      putChar x
--   </pre>
--
--   <ul><li>
--   In list comprehension generators, "in":
--   </li></ul>
--
--   <pre>
--   [ (x,y) | x <- [1..10], y <- ['a'..'z'] ]
--   </pre>
--
--   <ul><li>
--   In pattern guards, "matches":
--   </li></ul>
--
--   <pre>
--   f x y | Just z <- g x = True
--         | otherwise     = False
--   </pre>
@url #.3C-
@entry keyword <-

-- | In list comprehensions, "and":
--
--   <pre>
--   [ (x,y) | x <- [1..10], y <- ['a'..'z'], x > 42 ]
--   </pre>
@url #.2C
@entry keyword ,

-- | Used in definitions.
--
--   <pre>
--   x = 4
--   </pre>
@url #.3D
@entry keyword =

-- | Used to indicate instance contexts, for example:
--
--   <pre>
--   sort :: Ord a => [a] -> [a]
--   </pre>
@url #.3D.3E
@entry keyword =>

-- | In a Bird's style Literate Haskell file, the > character is used to
--   introduce a code line.
--
--   <pre>
--   comment line
--    
--   > main = print "hello world"
--   </pre>
@url #.3E
@entry keyword >

-- | <ul><li>
--   Implicit parameters
--   </li></ul>
--
--   <pre>
--   ghci> :t ?foo ++ "bar"
--   ?foo ++ "bar" :: (?foo::[Char]) => [Char]
--   </pre>
@url #.3F
@entry keyword ?

-- | <ul><li>
--   MagicHash
--   </li></ul>
--
--   <ul><li>
--   On the kind level: The kind of unboxed types (GHC-specific)
--   </li></ul>
--
--   <pre>
--   ghci> :m +GHC.Prim
--   ghci> :set -XMagicHash
--   ghci> :kind Int#
--   Int# :: #
--   </pre>
@url #.23
@entry keyword #

-- | <ul><li>
--   Is an ordinary operator name on the value level
--   </li></ul>
--
--   <ul><li>
--   On the kind level: The kind of boxed types (GHC-specific)
--   </li></ul>
--
--   <pre>
--   ghci> :kind Int
--   Int :: *
--   </pre>
@url #.2A
@entry keyword *

-- | Patterns of the form var@pat are called as-patterns, and allow one to
--   use var as a name for the value being matched by pat. For example:
--
--   <pre>
--   case e of { xs@(x:rest) -> if x==0 then rest else xs }
--   </pre>
--
--   is equivalent to:
--
--   <pre>
--   let { xs = e } in
--     case xs of { (x:rest) -> if x==0 then rest else xs }
--   </pre>
@url #.40
@entry keyword @

-- | <ul><li>
--   Template Haskell
--   </li></ul>
--
--   <ul><li>
--   Expression quotation: [| print 1 |]
--   </li><li>
--   Declaration quotation: [d| main = print 1 |]
--   </li><li>
--   Type quotation: [t| Either Int () |]
--   </li><li>
--   Pattern quotation: [p| (x,y) |]
--   </li><li>
--   Quasiquotation: [nameOfQuasiQuoter| ... |]
--   </li></ul>
@url #.5B.7C
@entry keyword [|

-- | <ul><li>
--   Template Haskell
--   </li></ul>
--
--   <ul><li>
--   Expression quotation: [| print 1 |]
--   </li><li>
--   Declaration quotation: [d| main = print 1 |]
--   </li><li>
--   Type quotation: [t| Either Int () |]
--   </li><li>
--   Pattern quotation: [p| (x,y) |]
--   </li><li>
--   Quasiquotation: [nameOfQuasiQuoter| ... |]
--   </li></ul>
@url #.7C.5D
@entry keyword |]

-- | The backslash "\" is used
--
--   <ul><li>
--   in multiline strings
--   </li></ul>
--
--   <pre>
--   "foo\
--     \bar"
--   </pre>
--
--   <ul><li>
--   in lambda functions
--   </li></ul>
--
--   <pre>
--   \x -> x + 1
--   </pre>
--
@url #.5C
@entry keyword \

-- | A function enclosed in back ticks "`" can be used as an infix
--   operator.
--
--   <pre>
--   2 `subtract` 10
--   </pre>
--
--   is the same as
--
--   <pre>
--   subtract 2 10
--   </pre>
@url #.60
@entry keyword `

-- | <ul><li>
--   Explicit block (disable layout), possibly with ";" .
--   </li></ul>
--
--   <ul><li>
--   Record update notation
--   </li></ul>
--
--   <pre>
--   changePrice :: Thing -> Price -> Thing
--   changePrice x new = x { price = new }
--   </pre>
--
--   <ul><li>
--   Comments (see below)
--   </li></ul>
@url #.7B
@entry keyword {

-- | <ul><li>
--   Explicit block (disable layout), possibly with ";" .
--   </li></ul>
--
--   <ul><li>
--   Record update notation
--   </li></ul>
--
--   <pre>
--   changePrice :: Thing -> Price -> Thing
--   changePrice x new = x { price = new }
--   </pre>
--
--   <ul><li>
--   Comments (see below)
--   </li></ul>
@url #.7D
@entry keyword }

-- | Everything between "{-" followed by a space and "-}" is a block
--   comment.
--
--   <pre>
--   {-
--   hello
--   world
--   -}
--   </pre>
@url #.7B-
@entry keyword {-

-- | Everything between "{-" followed by a space and "-}" is a block
--   comment.
--
--   <pre>
--   {-
--   hello
--   world
--   -}
--   </pre>
@url #-.7D
@entry keyword -}

-- | The "pipe" is used in several places
--
--   <ul><li>
--   Data type definitions, "or"
--   </li></ul>
--
--   <pre>
--   data Maybe a = Just a | Nothing
--   </pre>
--
--   <ul><li>
--   List comprehensions, "for" (as in, "list of <tt>a*a</tt> for
--   <tt>a</tt> in <tt>[1..]</tt>)
--   </li></ul>
--
--   <pre>
--   squares = [a*a | a <- [1..]]
--   </pre>
--
--   <ul><li>
--   Guards, "when"
--   </li></ul>
--
--   <pre>
--   safeTail x | null x    = []
--              | otherwise = tail x
--   </pre>
--
--   <ul><li>
--   Functional dependencies, "where"
--   </li></ul>
--
--   <pre>
--   class Contains c elt | c -> elt where
--      ...
--   </pre>
@url #.7C
@entry keyword |

-- | <ul><li>
--   Lazy pattern bindings. Matching the pattern ~pat against a value
--   always
--   </li></ul>
--
--   succeeds, and matching will only diverge when one of the variables
--   bound in the pattern is used.
--
--   <pre>
--   f1, f2 :: Maybe Int -> String
--   f1 x = case x of
--       Just n -> "Got it"
--   f2 x = case x of
--       ~(Just n) -> "Got it"
--    
--   (+++), (++++) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
--   (f +++ g) ~(x, y) = (f x, g y)
--   (f ++++ g) (x, y) = (f x, g y)
--   </pre>
--
--   Then we have:
--
--   <pre>
--   f1 Nothing
--   Exception: Non-exhaustive patterns in case
--    
--   f2 Nothing
--   "Got it"
--    
--   (const 1 +++ const 2) undefined
--   (1,2)
--    
--   (const 1 ++++ const 2) undefined
--   Exception: Prelude.undefined
--   </pre>
--
--   For more details see the Haskell Wikibook.
--
--   <ul><li>
--   Equality constraints. Assert that two types in a context must be the
--   same:
--   </li></ul>
--
--   <pre>
--   example :: F a ~ b => a -> b
--   </pre>
--
--   Here the type "F a" must be the same as the type "b", which allows
--   one to constrain polymorphism (especially where type families are
--   involved), but to a lesser extent than functional dependencies. See
--   Type Families.
@url #.7E
@entry keyword ~

-- | <pre>
--   import qualified Data.Map as M
--    
--   main = print (M.empty :: M.Map Int ())
--   </pre>
@url #as
@entry keyword as

-- | A case expression has the general form
--
--   <pre>
--   case e of { p1 match1 ; ... ; pn matchn }
--   </pre>
--
--   where each <tt>match</tt>i is of the general form
--
--   <pre>
--   | g1 -> e1
--     ...
--   | gm -> em
--       where decls
--   </pre>
--
--   Each alternative consists of patterns <tt>p</tt>i and their matches,
--   <tt>match</tt>i. Each<tt>match</tt>i in turn consists of a sequence of
--   pairs of guards <tt>g</tt>ij and bodies <tt>e</tt>ij (expressions),
--   followed by optional bindings (<tt>decls</tt>i) that scope over all of
--   the guards and expressions of the alternative. An alternative of the
--   form
--
--   <pre>
--   pat -> exp where decls
--   </pre>
--
--   is treated as shorthand for:
--
--   <pre>
--   pat | True -> exp
--     where decls
--   </pre>
--
--   A case expression must have at least one alternative and each
--   alternative must have at least one body. Each body must have the same
--   type, and the type of the whole expression is that type.
--
--   A case expression is evaluated by pattern matching the expression
--   <tt>e</tt> against the individual alternatives. The alternatives are
--   tried sequentially, from top to bottom. If <tt>e</tt> matches the
--   pattern in the alternative, the guards for that alternative are tried
--   sequentially from top to bottom, in the environment of the case
--   expression extended first by the bindings created during the matching
--   of the pattern, and then by the <tt>decls</tt>i in the <tt>where</tt>
--   clause associated with that alternative. If one of the guards
--   evaluates to <tt>True</tt>, the corresponding right-hand side is
--   evaluated in the same environment as the guard. If all the guards
--   evaluate to <tt>False</tt>, matching continues with the next
--   alternative. If no match succeeds, the result is _|_.
@url #case
@entry keyword case

-- | A case expression has the general form
--
--   <pre>
--   case e of { p1 match1 ; ... ; pn matchn }
--   </pre>
--
--   where each <tt>match</tt>i is of the general form
--
--   <pre>
--   | g1 -> e1
--     ...
--   | gm -> em
--       where decls
--   </pre>
--
--   Each alternative consists of patterns <tt>p</tt>i and their matches,
--   <tt>match</tt>i. Each<tt>match</tt>i in turn consists of a sequence of
--   pairs of guards <tt>g</tt>ij and bodies <tt>e</tt>ij (expressions),
--   followed by optional bindings (<tt>decls</tt>i) that scope over all of
--   the guards and expressions of the alternative. An alternative of the
--   form
--
--   <pre>
--   pat -> exp where decls
--   </pre>
--
--   is treated as shorthand for:
--
--   <pre>
--   pat | True -> exp
--     where decls
--   </pre>
--
--   A case expression must have at least one alternative and each
--   alternative must have at least one body. Each body must have the same
--   type, and the type of the whole expression is that type.
--
--   A case expression is evaluated by pattern matching the expression
--   <tt>e</tt> against the individual alternatives. The alternatives are
--   tried sequentially, from top to bottom. If <tt>e</tt> matches the
--   pattern in the alternative, the guards for that alternative are tried
--   sequentially from top to bottom, in the environment of the case
--   expression extended first by the bindings created during the matching
--   of the pattern, and then by the <tt>decls</tt>i in the <tt>where</tt>
--   clause associated with that alternative. If one of the guards
--   evaluates to <tt>True</tt>, the corresponding right-hand side is
--   evaluated in the same environment as the guard. If all the guards
--   evaluate to <tt>False</tt>, matching continues with the next
--   alternative. If no match succeeds, the result is _|_.
@url #of
@entry keyword of

-- | A class declaration introduces a new type class and the overloaded
--   operations that must be supported by any type that is an instance of
--   that class.
--
--   <pre>
--   class Num a  where
--     (+)    :: a -> a -> a
--     negate :: a -> a
--   </pre>
@url #class
@entry keyword class

-- | The data declaration is how one introduces new algebraic data types
--   into Haskell. For example:
--
--   <pre>
--   data Set a = NilSet
--              | ConsSet a (Set a)
--   </pre>
--
--   Another example, to create a datatype to hold an abstract syntax tree
--   for an expression, one could use:
--
--   <pre>
--   data Exp = Ebin   Operator Exp Exp
--            | Eunary Operator Exp
--            | Efun   FunctionIdentifier [Exp]
--            | Eid    SimpleIdentifier
--   </pre>
--
--   where the types <tt>Operator, FunctionIdentifier</tt> and
--   <tt>SimpleIdentifier</tt> are defined elsewhere.
--
--   See the page on types for more information, links and examples.
@url #data
@entry keyword data

-- | Declares a datatype family (see type families). GHC language
--   extension.
@url #data_family
@entry keyword data family

-- | Declares a datatype family instance (see type families). GHC language
--   extension.
--
@url #data_instance
@entry keyword data instance

-- | Ambiguities in the class Num are most common, so Haskell provides a
--   way to resolve them---with a default declaration:
--
--   <pre>
--   default (Int)
--   </pre>
--
--   Only one default declaration is permitted per module, and its effect
--   is limited to that module. If no default declaration is given in a
--   module then it assumed to be:
--
--   <pre>
--   default (Integer, Double)
--   </pre>
@url #default
@entry keyword default

-- | data and newtype declarations contain an optional deriving form. If
--   the form is included, then derived instance declarations are
--   automatically generated for the datatype in each of the named classes.
--
--   Derived instances provide convenient commonly-used operations for
--   user-defined datatypes. For example, derived instances for datatypes
--   in the class Eq define the operations == and /=, freeing the
--   programmer from the need to define them.
--
--   <pre>
--   data T = A
--          | B
--          | C
--          deriving (Eq, Ord, Show)
--   </pre>
--
--   In the case of newtypes, GHC extends this mechanism to Cunning
--   Newtype Deriving.
@url #deriving
@entry keyword deriving

-- | Standalone deriving (GHC language extension).
--
--   <pre>
--   {-# LANGUAGE StandaloneDeriving #-}
--   data A = A
--    
--   deriving instance Show A
--   </pre>
@url #deriving_instance
@entry keyword deriving instance

-- | Syntactic sugar for use with monadic expressions. For example:
--
--   <pre>
--   do { x ; result <- y ; foo result }
--   </pre>
--
--   is shorthand for:
--
--   <pre>
--   x >>
--   y >>= \result ->
--   foo result
--   </pre>
@url #do
@entry keyword do

-- | This is a GHC/Hugs extension, and as such is not portable Haskell
--   98/2010. It is only a reserved word within types.
--
--   Type variables in a Haskell type expression are all assumed to be
--   universally quantified; there is no explicit syntax for universal
--   quantification, in standard Haskell 98/2010. For example, the type
--   expressiona -> a denotes the type forall a. a ->a.
--
--   For clarity, however, we often write quantification explicitly when
--   discussing the types of Haskell programs. When we write an explicitly
--   quantified type, the scope of the forall extends as far to the right
--   as possible; for example,
--
--   <pre>
--   forall a. a -> a
--   </pre>
--
--   means
--
--   <pre>
--   forall a. (a -> a)
--   GHC introduces a forall keyword, allowing explicit quantification, for example, to encode
--   </pre>
--
--   existential types:
--
--   <pre>
--   data Foo = forall a. MkFoo a (a -> Bool)
--            | Nil
--    
--   MkFoo :: forall a. a -> (a -> Bool) -> Foo
--   Nil   :: Foo
--    
--   [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
--   </pre>
@url #forall
@entry keyword forall

@url #foreign
@entry keyword foreign

-- | When importing modules, without introducing a name into scope,
--   entities can be excluded by using the form
--
--   <pre>
--   hiding (import1 , ... , importn )
--   </pre>
--
--   which specifies that all entities exported by the named module should
--   be imported except for those named in the list.
--
--   For example:
--
--   <pre>
--   import Prelude hiding (lookup,filter,foldr,foldl,null,map)
--   </pre>
@url #hiding
@entry keyword hiding

-- | A conditional expression has the form:
--
--   <pre>
--   if e1 then e2 else e3
--   </pre>
--
--   and returns the value of e2 if the value of e1 is True, e3 if e1 is
--   False, and _|_ otherwise.
--
--   <pre>
--   max a b = if a > b then a else b
--   </pre>
@url #if
@entry keyword if

-- | A conditional expression has the form:
--
--   <pre>
--   if e1 then e2 else e3
--   </pre>
--
--   and returns the value of e2 if the value of e1 is True, e3 if e1 is
--   False, and _|_ otherwise.
--
--   <pre>
--   max a b = if a > b then a else b
--   </pre>
@url #then
@entry keyword then

-- | A conditional expression has the form:
--
--   <pre>
--   if e1 then e2 else e3
--   </pre>
--
--   and returns the value of e2 if the value of e1 is True, e3 if e1 is
--   False, and _|_ otherwise.
--
--   <pre>
--   max a b = if a > b then a else b
--   </pre>
@url #else
@entry keyword else

-- | Modules may reference other modules via explicit import declarations,
--   each giving the name of a module to be imported and specifying its
--   entities to be imported.
--
--   For example:
--
--   <pre>
--    module Main where
--      import A
--      import B
--      main = A.f >> B.f
--
--    module A where
--      f = ...
--
--    module B where
--      f = ...
--   </pre>
--
--   See also as, hiding , qualified and the page Import
@url #import
@entry keyword import

-- | A fixity declaration gives the fixity and binding precedence of one
--   or more operators. The integer in a fixity declaration must be in the
--   range 0 to 9. A fixity declaration may appear anywhere that a type
--   signature appears and, like a type signature, declares a property of a
--   particular operator.
--
--   There are three kinds of fixity, non-, left- and right-associativity
--   (infix, infixl, and infixr, respectively), and ten precedence levels,
--   0 to 9 inclusive (level 0 binds least tightly, and level 9 binds most
--   tightly).
--
--   <pre>
--   module Bar where
--     infixr 7 `op`
--     op = ...
--   </pre>
@url #infix
@entry keyword infix

-- | A fixity declaration gives the fixity and binding precedence of one
--   or more operators. The integer in a fixity declaration must be in the
--   range 0 to 9. A fixity declaration may appear anywhere that a type
--   signature appears and, like a type signature, declares a property of a
--   particular operator.
--
--   There are three kinds of fixity, non-, left- and right-associativity
--   (infix, infixl, and infixr, respectively), and ten precedence levels,
--   0 to 9 inclusive (level 0 binds least tightly, and level 9 binds most
--   tightly).
--
--   <pre>
--   module Bar where
--     infixr 7 `op`
--     op = ...
--   </pre>
@url #infixl
@entry keyword infixl

-- | A fixity declaration gives the fixity and binding precedence of one
--   or more operators. The integer in a fixity declaration must be in the
--   range 0 to 9. A fixity declaration may appear anywhere that a type
--   signature appears and, like a type signature, declares a property of a
--   particular operator.
--
--   There are three kinds of fixity, non-, left- and right-associativity
--   (infix, infixl, and infixr, respectively), and ten precedence levels,
--   0 to 9 inclusive (level 0 binds least tightly, and level 9 binds most
--   tightly).
--
--   <pre>
--   module Bar where
--     infixr 7 `op`
--     op = ...
--   </pre>
@url #infixr
@entry keyword infixr

-- | An instance declaration declares that a type is an instance of a
--   class and includes the definitions of the overloaded operations -
--   called class methods - instantiated on the named type.
--
--   <pre>
--   instance Num Int  where
--     x + y       =  addInt x y
--     negate x    =  negateInt x
--   </pre>
@url #instance
@entry keyword instance

-- | Let expressions have the general form:
--
--   <pre>
--   let { d1 ; ... ; dn } in e
--   </pre>
--
--   They introduce a nested, lexically-scoped, mutually-recursive list of
--   declarations (let is often called letrec in other languages). The
--   scope of the declarations is the expression e and the right hand side
--   of the declarations. Within do-blocks or list comprehensions let { d1
--   ; ... ; dn } without in serves to indroduce local bindings.
@url #let
@entry keyword let

-- | Let expressions have the general form:
--
--   <pre>
--   let { d1 ; ... ; dn } in e
--   </pre>
--
--   They introduce a nested, lexically-scoped, mutually-recursive list of
--   declarations (let is often called letrec in other languages). The
--   scope of the declarations is the expression e and the right hand side
--   of the declarations. Within do-blocks or list comprehensions let { d1
--   ; ... ; dn } without in serves to indroduce local bindings.
@url #in
@entry keyword in

@url #mdo
@entry keyword mdo

-- | Taken from: A Gentle Introduction to Haskell, Version 98
--
--   Technically speaking, a module is really just one big declaration
--   which begins with the keyword module; here's an example for a module
--   whose name is Tree:
--
--   <pre>
--   module Tree ( Tree(Leaf,Branch), fringe ) where
--    
--   data Tree a                = Leaf a | Branch (Tree a) (Tree a)
--    
--   fringe :: Tree a -> [a]
--   fringe (Leaf x)            = [x]
--   fringe (Branch left right) = fringe left ++ fringe right
--   </pre>
@url #module
@entry keyword module

-- | The <tt>newtype</tt> declaration is how one introduces a renaming for
--   an algebraic data type into Haskell. This is different from
--   <tt>type</tt> below, as a <tt>newtype</tt> requires a new constructor
--   as well. As an example, when writing a compiler one sometimes further
--   qualifies <tt>Identifier</tt>s to assist in type safety checks:
--
--   <pre>
--   newtype SimpleIdentifier = SimpleIdentifier Identifier
--   newtype FunctionIdentifier = FunctionIdentifier Identifier
--   </pre>
--
--   Most often, one supplies smart constructors and destructors for these
--   to ease working with them.
--
--   See the page on types for more information, links and examples.
--
--   For the differences between <tt>newtype</tt> and <tt>data</tt>, see
--   Newtype.
@url #newtype
@entry keyword newtype

-- | proc (arrow abstraction) is a kind of lambda, except that it
--   constructs an arrow instead of a function.
--
--   Arrow notation
@url #proc
@entry keyword proc

-- | Used to import a module, but not introduce a name into scope. For
--   example, Data.Map exports lookup, which would clash with the Prelude
--   version of lookup, to fix this:
--
--   <pre>
--   import qualified Data.Map
--    
--   f x = lookup x -- use the Prelude version
--   g x = Data.Map.lookup x -- use the Data.Map version
--   </pre>
--
--   Of course, Data.Map is a bit of a mouthful, so qualified also allows
--   the use of as.
--
--   <pre>
--   import qualified Data.Map as M
--    
--   f x = lookup x -- use Prelude version
--   g x = M.lookup x -- use Data.Map version
--   </pre>
@url #qualified
@entry keyword qualified

-- | The rec keyword can be used when the <tt>-XDoRec</tt> flag is given;
--   it allows recursive bindings in a do-block.
--
--   <pre>
--   {-# LANGUAGE DoRec #-}
--   justOnes = do { rec { xs <- Just (1:xs) }
--                 ; return (map negate xs) }
--   </pre>
@url #rec
@entry keyword rec

-- | The <tt>type</tt> declaration is how one introduces an alias for an
--   algebraic data type into Haskell. As an example, when writing a
--   compiler one often creates an alias for identifiers:
--
--   <pre>
--   type Identifier = String
--   </pre>
--
--   This allows you to use <tt>Identifer</tt> wherever you had used
--   <tt>String</tt> and if something is of type <tt>Identifier</tt> it may
--   be used wherever a <tt>String</tt> is expected.
--
--   See the page on types for more information, links and examples.
--
--   Some common <tt>type</tt> declarations in the Prelude include:
--
--   <pre>
--   type FilePath = String
--   type String = [Char]
--   type Rational = Ratio Integer
--   type ReadS a = String -> [(a,String)]
--   type ShowS = String -> String
--   </pre>
@url #type
@entry keyword type

-- | Declares a type synonym family (see type families). GHC language
--   extension.
@url #type_family
@entry keyword type family

-- | Declares a type synonym family instance (see type families). GHC
--   language extension.
--
@url #type_instance
@entry keyword type instance

-- | Used to introduce a module, instance, class or GADT:
--
--   <pre>
--   module Main where
--    
--   class Num a where
--       ...
--    
--   instance Num Int  where
--       ...
--    
--   data Something a where
--      ...
--   </pre>
--
--   And to bind local variables:
--
--   <pre>
--   f x = y
--       where y = x * 2
--    
--   g z | z > 2 = y
--       where y = x * 2
--   </pre>
@url #where
@entry keyword where
