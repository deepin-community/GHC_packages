Description: Fix alignment restrictions
 Ensure that alignment constraints are fulfilled in all architectures.
 This makes the code portable and fixes a FTBFS for the armhf architecture.
Author: Ilias Tsitsimpis <i.tsitsimpis@gmail.com>
Forwarded: https://github.com/snoyberg/conduit/pull/269
Index: b/Data/Conduit/Binary.hs
===================================================================
--- a/Data/Conduit/Binary.hs
+++ b/Data/Conduit/Binary.hs
@@ -76,6 +76,8 @@ import Control.Monad.Trans.Resource (Mon
 import Control.Monad.Catch (MonadThrow (..))
 import Control.Exception (Exception)
 import Data.Typeable (Typeable)
+import Foreign.Marshal (alloca, copyBytes)
+import Foreign.Ptr (Ptr)
 
 -- | Stream the contents of a file as binary data.
 --
@@ -501,7 +503,10 @@ sinkStorableHelper wrap failure = do
 
     -- Given a bytestring of exactly the correct size, grab the value
     process bs = return $! wrap $! inlinePerformIO $!
-        unsafeUseAsCString bs (peek . castPtr)
+        unsafeUseAsCString bs (safePeek undefined . castPtr)
+
+    safePeek :: a -> Ptr a -> IO a
+    safePeek val ptr = alloca (\t -> copyBytes t ptr (sizeOf val) >> peek t)
 {-# INLINE sinkStorableHelper #-}
 
 data SinkStorableException = SinkStorableInsufficientBytes
Index: b/test/Data/Conduit/BinarySpec.hs
===================================================================
--- a/test/Data/Conduit/BinarySpec.hs
+++ b/test/Data/Conduit/BinarySpec.hs
@@ -20,9 +20,11 @@ import Data.Functor.Identity
 import Test.QuickCheck.Arbitrary (Arbitrary, arbitrary)
 import Test.QuickCheck.Gen (Gen, oneof)
 import Data.Word (Word8)
-import Foreign.Storable (Storable, sizeOf, pokeByteOff)
+import Foreign.Storable (Storable, sizeOf, pokeByteOff, alignment)
 import Data.Typeable (Typeable)
-import Data.ByteString.Internal (unsafeCreate)
+import Data.ByteString.Internal (createAndTrim')
+import Foreign.Ptr (alignPtr, minusPtr)
+import System.IO.Unsafe (unsafePerformIO)
 import Control.Applicative ((<$>), (<*>))
 
 spec :: Spec
@@ -277,19 +279,19 @@ withSomeStorable :: SomeStorable
                  -> b
 withSomeStorable (SomeStorable x) f = f x
 
-someStorables :: [SomeStorable] -> S.ByteString
-someStorables stores0 =
-    unsafeCreate size start
+someStorable :: SomeStorable -> S.ByteString
+someStorable store =
+    fst $ unsafePerformIO $ createAndTrim' (size + align) start
   where
-    size = sum $ map (\x -> withSomeStorable x sizeOf) stores0
+    size = withSomeStorable store sizeOf
+    align = withSomeStorable store alignment
+    start ptr = do
+        let off = minusPtr ptr (alignPtr ptr align)
+        withSomeStorable store (pokeByteOff ptr off)
+        return (off, size, ())
 
-    start ptr =
-        go stores0 0
-      where
-        go [] _ = return ()
-        go (x:rest) off = do
-            withSomeStorable x (pokeByteOff ptr off)
-            go rest (off + withSomeStorable x sizeOf)
+someStorables :: [SomeStorable] -> S.ByteString
+someStorables = S.concat . map someStorable
 
 it' :: String -> IO () -> Spec
 it' = it
