#! /bin/sh /usr/share/dpatch/dpatch-run
## 03_add-readline-support.dpatch by Arjan Oosting <arjanoosting@home.nl>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad helium-1.6~/helium/src/Makefile.in helium-1.6/helium/src/Makefile.in
--- helium-1.6~/helium/src/Makefile.in	2006-09-15 15:06:31.000000000 +0200
+++ helium-1.6/helium/src/Makefile.in	2006-09-15 15:06:32.000000000 +0200
@@ -48,7 +48,7 @@
 PACKAGENET =
 endif
 HC_OPTS = -static -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances \
-		$(PACKAGENET) -package lang -package text -i$(IFACES) $(EXTRA_HC_OPTS)
+		$(PACKAGENET) -package lang -package text -package editline -i$(IFACES) $(EXTRA_HC_OPTS)

 AG      = @WithAG@
 AG_OPTS = -mscfr
diff -urNad helium-1.6~/helium/src/texthint/Main.hs helium-1.6/helium/src/texthint/Main.hs
--- helium-1.6~/helium/src/texthint/Main.hs	2006-09-15 15:06:18.000000000 +0200
+++ helium-1.6/helium/src/texthint/Main.hs	2006-09-15 15:07:44.000000000 +0200
@@ -15,6 +15,7 @@
 import Monad(when)
 import IO(stdout, hFlush)
 import System(system, getEnv, getArgs, exitWith, ExitCode(..))
+import qualified System.Console.Editline.Readline as RL
 import OSSpecific(slash)
 import Directory

@@ -75,8 +76,11 @@
         else
             return initialState

-    -- Enter read-eval-print loop
+    -- Initialize editline
+    RL.initialize
+
+    -- Enter read-eval-print loop
     loop stateAfterLoad

     return ()

@@ -89,21 +89,24 @@

 loop :: State -> IO State
 loop state = do
-    putStr (prompt state)
-    hFlush stdout
-    command' <- getLine
-    let command = trim command'
+    command' <- RL.readline (prompt state)
+    let command = fmap trim command'
     newState <- case command of
-        (':':cmd:rest) ->
+        (Just (':':cmd:rest)) -> do
+            RL.addHistory (':':cmd:rest)
             processCommand (toLower cmd) (trim rest) state
-        (':':_) -> do
+        (Just (':':_)) -> do
             putStrLn "Expecting command after colon. Type :? for help"
             return state
-        expression -> do
+        (Just expression) -> do
             if null expression
                 then return ()
-                else processExpression expression state
+                else do
+                    RL.addHistory expression
+                    processExpression expression state
             return state
+        (Nothing) -> do
+            do return state
     loop newState
   where
     prompt :: State -> String
