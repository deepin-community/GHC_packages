Description: Num does no longer imply Eq or Show. See GHC 7.4.1 release notes.
Author: Iulian Udrea <iulian@physics.org>

--- a/EigensystemNum.hs
+++ b/EigensystemNum.hs
@@ -3,10 +3,10 @@
 import Orthogonals
 import Data.List

-mult :: Num a => [[a]] -> [[a]] -> [[a]]
+mult :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 mult x y = matrix_matrix x (transposed y)

-matSqr :: Num a => [[a]] -> [[a]]
+matSqr :: (Eq a, Num a) => [[a]] -> [[a]]
 matSqr x = mult x x

 powerIter :: (Fractional a, Ord a) => [[a]] -> [([[a]],[[a]])]
@@ -27,10 +27,10 @@
 specRadApprox :: (Fractional a, Ord a) => [[a]] -> [a]
 specRadApprox = map getGrowth . powerIter

-eigenValuesApprox :: (Scalar a, Fractional a) => [[a]] -> [[a]]
+eigenValuesApprox :: (Eq a, Scalar a, Fractional a) => [[a]] -> [[a]]
 eigenValuesApprox = map diagonals . iterate similar_to

-limit :: (Num a, Ord a) => a -> [a] -> a
+limit :: (Eq a, Num a, Ord a) => a -> [a] -> a
 limit tol (x0:x1:xs) = if abs (x1-x0) < tol * abs x0
                        then x0
		       else limit tol (x1:xs)
--- a/Orthogonals.lhs
+++ b/Orthogonals.lhs
@@ -283,7 +283,7 @@

 <pre>

-> bra_ket :: (Scalar a, Num a) => [a] -> [a] -> a
+> bra_ket :: (Scalar a, Eq a, Num a) => [a] -> [a] -> a
 > bra_ket u v =
 >       --
 >       -- Scalar product of two vectors u and v,
@@ -340,16 +340,16 @@
 >     scaled u       = [(x/m):+(y/m) | x:+y <- u]
 >        where m = maximum [max (abs x) (abs y) | x:+y <- u]

-> norm1 :: (Num a) => [a] -> a
+> norm1 :: (Eq a, Num a) => [a] -> a
 > norm1 = sum . map abs

-> norminf :: (Num a, Ord a) => [a] -> a
+> norminf :: (Eq a, Num a, Ord a) => [a] -> a
 > norminf = maximum . map abs

-> matnorm1 :: (Num a, Ord a) => [[a]] -> a
+> matnorm1 :: (Eq a, Num a, Ord a) => [[a]] -> a
 > matnorm1 = matnorminf . transposed

-> matnorminf :: (Num a, Ord a) => [[a]] -> a
+> matnorminf :: (Eq a, Num a, Ord a) => [[a]] -> a
 > matnorminf = maximum . map norm1


@@ -362,7 +362,7 @@
         We will call it a 'sum_product".
 <pre>

-> sum_product :: Num a => [a] -> [a] -> a
+> sum_product :: (Eq a, Num a) => [a] -> [a] -> a
 > sum_product u v =
 >       --
 >       -- Similar to scalar product but without
@@ -460,7 +460,7 @@
 >     --
 >     [zipWith f ak bk | (ak,bk) <- zip a b]

-> add_matrices :: (Num a) => t -> t1 -> [[a]] -> [[a]] -> [[a]]
+> add_matrices :: (Eq a, Num a) => t -> t1 -> [[a]] -> [[a]] -> [[a]]
 > add_matrices _ _ = matrix_zipWith (+)

 </pre>
@@ -497,7 +497,7 @@

 <pre>

-> matrix_matrix :: Num a => [[a]] -> [[a]] -> [[a]]
+> matrix_matrix :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 > matrix_matrix a b
 > --
 > -- A matrix being an inner product
@@ -512,7 +512,7 @@
 >       | otherwise = ([sum_product (head a) bi | bi <- b])
 >                  : matrix_matrix (tail a) b

-> matrix_matrix' :: (Num a) => [[a]] -> [[a]] -> [[a]]
+> matrix_matrix' :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 > matrix_matrix' a b
 >       --
 >       -- Similar to "matrix_matrix"
@@ -524,7 +524,7 @@
 >                    : matrix_matrix' a (tail b)


-> triangle_matrix' :: Num a => [[a]] -> [[a]] -> [[a]]
+> triangle_matrix' :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 > triangle_matrix' r q =
 >       --
 >       -- List of columns of of a product of
@@ -553,7 +553,7 @@
         that list "a" represents rows of matrix A.
 <pre>

-> matrix_ket :: Num a => [[a]] -> [a] -> [a]
+> matrix_ket :: (Eq a, Num a) => [[a]] -> [a] -> [a]
 > matrix_ket a v = [sum_product ai v| ai <- a]

 </pre>
@@ -570,7 +570,7 @@
         instead of "sum_product".
 <pre>

-> bra_matrix :: (Scalar a, Num a) => [a] -> [[a]] -> [a]
+> bra_matrix :: (Scalar a, Eq a, Num a) => [a] -> [[a]] -> [a]
 > bra_matrix v a = [bra_ket v ai | ai <- a]

 </pre>
@@ -587,7 +587,7 @@
         rows of matrix A.
 <pre>

-> bra_matrix_ket :: (Scalar a, Num a) => [a] -> [[a]] -> [a] -> a
+> bra_matrix_ket :: (Scalar a, Eq a, Num a) => [a] -> [[a]] -> [a] -> a
 > bra_matrix_ket u a v =
 >     bra_ket u (matrix_ket a v)

@@ -599,7 +599,7 @@
         Below is a function which multiplies matrix by a scalar:
 <pre>

-> scalar_matrix :: Num a => a -> [[a]] -> [[a]]
+> scalar_matrix :: (Eq a, Num a) => a -> [[a]] -> [[a]]
 > scalar_matrix alpha a =
 >       [[alpha*aij| aij <- ai] | ai<-a]

@@ -641,7 +641,7 @@

 <pre>

-> orthogonals :: (Scalar a, Fractional a) => [a] -> [[a]]
+> orthogonals :: (Eq a, Scalar a, Fractional a) => [a] -> [[a]]
 > orthogonals x =
 >       --
 >       -- List of (n-1) linearly independent vectors,
@@ -661,7 +661,7 @@
 >           next i = if (i+1) == k then (i+2) else (i+1)
 >           k = length (takeWhile (== 0) x) -- first non-zero component of x

-> gram_schmidt :: (Scalar a, Fractional a) => [[a]] -> [a] -> [a]
+> gram_schmidt :: (Eq a, Scalar a, Fractional a) => [[a]] -> [a] -> [a]
 > gram_schmidt a u =
 >       --
 >       -- Projection of vector | u > on some direction
@@ -757,7 +757,7 @@
         Below is a function that does that for any problem size:
 <pre>

-> one_ket_triangle :: (Scalar a, Fractional a) => [[a]] -> [a] -> [([a],a)]
+> one_ket_triangle :: (Eq a, Scalar a, Fractional a) => [[a]] -> [a] -> [([a],a)]
 > one_ket_triangle a b
 >     --
 >     -- List of pairs: (p, q) representing
@@ -783,7 +783,7 @@

 <pre>

-> one_ket_solution :: (Fractional a, Scalar a) => [[a]] -> [a] -> [a]
+> one_ket_solution :: (Eq a, Fractional a, Scalar a) => [[a]] -> [a] -> [a]
 > one_ket_solution a b =
 >     --
 >     -- List representing vector |x>, which is
@@ -809,7 +809,7 @@
         of just one:
 <pre>

-> many_kets_triangle :: (Scalar a, Fractional a) => [[a]] -> [[a]] -> [([a],[a])]
+> many_kets_triangle :: (Eq a, Scalar a, Fractional a) => [[a]] -> [[a]] -> [([a],[a])]
 > many_kets_triangle a b
 >     --
 >     -- List of pairs: (p, q) representing
@@ -838,7 +838,7 @@
         several ket-vectors on the right hand side.
 <pre>

-> many_kets_solution :: (Scalar a, Fractional a) => [[a]] -> [[a]] -> [[a]]
+> many_kets_solution :: (Eq a, Scalar a, Fractional a) => [[a]] -> [[a]] -> [[a]]
 > many_kets_solution a b =
 >     --
 >     -- List of columns of matrix X, which is
@@ -880,7 +880,7 @@
         It follows that matrix X is an inverse of A; that is X = A<sup>-1</sup>.
 <pre>

-> inverse :: (Scalar a, Fractional a) => [[a]] -> [[a]]
+> inverse :: (Eq a, Scalar a, Fractional a) => [[a]] -> [[a]]
 > inverse a = many_kets_solution a (unit_matrix (length a))
 >       --
 >       -- List of columns of inverse of matrix A
@@ -951,7 +951,7 @@

 <pre>

-> factors_QR :: (Fractional a, Scalar a) => [[a]] -> ([[a]],[[a]])
+> factors_QR :: (Eq a, Fractional a, Scalar a) => [[a]] -> ([[a]],[[a]])
 > factors_QR a =
 >       --
 >       -- A pair of matrices (Q, R), such that
@@ -979,7 +979,7 @@

 <pre>

-> determinant :: (Fractional a, Scalar a) => [[a]] -> a
+> determinant :: (Eq a, Fractional a, Scalar a) => [[a]] -> a
 > determinant a =
 >    let (q,r) = factors_QR a
 >    -- matrix Q is not normed so we have to respect the norms of its rows
@@ -992,7 +992,7 @@

 <pre>

-> determinantNaive :: (Num a) => [[a]] -> a
+> determinantNaive :: (Eq a, Num a) => [[a]] -> a
 > determinantNaive [] = 1
 > determinantNaive m  =
 >    sum (alternate
@@ -1011,7 +1011,7 @@

 <pre>

-> determinantClow :: (Num a) => [[a]] -> a
+> determinantClow :: (Eq a, Num a) => [[a]] -> a
 > determinantClow [] = 1
 > determinantClow m =
 >    let lm = length m
@@ -1026,7 +1026,7 @@

 <pre>

-> newClow :: (Num a) => [[a]] -> [[a]] -> [a]
+> newClow :: (Eq a, Num a) => [[a]] -> [[a]] -> [a]
 > newClow a c =
 >    scanl (-) 0
 >          (sumVec (zipWith (zipWith (*)) (List.transpose a) c))
@@ -1038,7 +1038,7 @@

 <pre>

-> extendClow :: (Num a) => [[a]] -> [[a]] -> [[a]]
+> extendClow :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 > extendClow a c =
 >    map (\ai -> sumVec (zipWith scaleVec ai c)) a

@@ -1052,7 +1052,7 @@

 <pre>

-> longerClow :: (Num a) => [[a]] -> [[a]] -> [[a]]
+> longerClow :: (Eq a, Num a) => [[a]] -> [[a]] -> [[a]]
 > longerClow a c =
 >    let diagonal = newClow a c
 >        triangle = extendClow a c
@@ -1075,25 +1075,25 @@
 > removeEach xs =
 >    zipWith (++) (List.inits xs) (tail (List.tails xs))
 >
-> alternate :: (Num a) => [a] -> [a]
+> alternate :: (Eq a, Num a) => [a] -> [a]
 > alternate = zipWith id (cycle [id, negate])
 >
-> parityFlip :: Num a => Int -> a -> a
+> parityFlip :: (Eq a, Num a) => Int -> a -> a
 > parityFlip n x = if even n then x else -x
 >
 > {-| Weight a list of numbers by a scalar. -}
-> scaleVec :: (Num a) => a -> [a] -> [a]
+> scaleVec :: (Eq a, Num a) => a -> [a] -> [a]
 > scaleVec k = map (k*)
 >
 > {-| Add corresponding numbers of two lists. -}
 > {- don't use zipWith because it clips to the shorter list -}
-> addVec :: (Num a) => [a] -> [a] -> [a]
+> addVec :: (Eq a, Num a) => [a] -> [a] -> [a]
 > addVec x [] = x
 > addVec [] y = y
 > addVec (x:xs) (y:ys) = x+y : addVec xs ys
 >
 > {-| Add some lists. -}
-> sumVec :: (Num a) => [[a]] -> [a]
+> sumVec :: (Eq a, Num a) => [[a]] -> [a]
 > sumVec = foldl addVec []

 </pre>
@@ -1188,7 +1188,7 @@
 <pre>


-> similar_to :: (Fractional a, Scalar a) => [[a]] -> [[a]]
+> similar_to :: (Eq a, Fractional a, Scalar a) => [[a]] -> [[a]]
 > similar_to a =
 >       --
 >       -- List of columns of matrix A1 similar to A
@@ -1201,7 +1201,7 @@
 >       where
 >           (q,r) = factors_QR a

-> iterated_eigenvalues :: (Scalar a1, Fractional a1, Num a) => [[a1]] -> a -> [[a1]]
+> iterated_eigenvalues :: (Eq a1, Scalar a1, Fractional a1, Eq a, Num a) => [[a1]] -> a -> [[a1]]
 > iterated_eigenvalues a n
 >       --
 >       -- List of vectors representing
@@ -1215,7 +1215,7 @@
 >       | otherwise = (diagonals a)
 >                     : iterated_eigenvalues (similar_to a) (n-1)

-> eigenvalues :: (Scalar a1, Fractional a1, Num a) => [[a1]] -> a -> [a1]
+> eigenvalues :: (Eq a1, Scalar a1, Fractional a1, Eq a, Num a) => [[a1]] -> a -> [a1]
 > eigenvalues a n
 >       --
 >       -- Eigenvalues of matrix A
@@ -1298,7 +1298,7 @@

 <pre>

-> add_to_diagonal :: Num a => a -> [[a]] -> [[a]]
+> add_to_diagonal :: (Eq a, Num a) => a -> [[a]] -> [[a]]
 > add_to_diagonal alpha a =
 >       --
 >       -- Add constant alpha to diagonal of matrix A
@@ -1586,7 +1586,7 @@

 <pre>

-> eigenkets :: (Scalar a, Fractional a) => [[a]] -> [a] -> [[a]]
+> eigenkets :: (Eq a, Scalar a, Fractional a) => [[a]] -> [a] -> [[a]]
 > eigenkets a u
 >       --
 >       -- List of eigenkets of a square matrix A
@@ -1683,7 +1683,7 @@
         follows.
 <pre>

-> eigenket' :: (Scalar a, Fractional a) => [[a]] -> a -> a -> [a] -> [a]
+> eigenket' :: (Eq a, Scalar a, Fractional a) => [[a]] -> a -> a -> [a] -> [a]
 > eigenket' a alpha eps x' =
 >       --
 >       -- Eigenket of matrix A corresponding to eigenvalue alpha
@@ -1784,7 +1784,7 @@
         where n = 20, etc.


-> unit_matrix :: Num a => Int -> [[a]]
+> unit_matrix :: (Eq a, Num a) => Int -> [[a]]
 > unit_matrix m =
 >       --
 >       -- Unit square matrix of with dimensions m x m
@@ -1797,7 +1797,7 @@
 >           | otherwise = 0:(g (i+1) k)
 >

-> unit_vector :: Num a => Int -> Int -> [a]
+> unit_vector :: (Eq a, Num a) => Int -> Int -> [a]
 > unit_vector i m =
 >       --
 >       -- Unit vector of length m
--- a/Roots.hs
+++ b/Roots.hs
@@ -65,7 +65,7 @@
                   g2    = g^(2::Int)
                   n     = genericLength bs

-polynomial_value :: Num a => [a] -> a -> a
+polynomial_value :: (Eq a, Num a) => [a] -> a -> a
 polynomial_value as x =
       --
       -- Value of polynomial a0 + a1 x  + a2 x^2 ...
@@ -76,7 +76,7 @@
       where
           u y a b = a + b*y

-polynomial_derivative :: Num a => [a] -> [a]
+polynomial_derivative :: (Eq a, Num a) => [a] -> [a]
 polynomial_derivative as
       --
       -- List of coefficients for derivative of polynomial
