Source: frown
Section: devel
Priority: optional
Maintainer: Arjan Oosting <arjan@debian.org>
Build-Depends: @cdbs@, ghc6, hevea, lhs2tex, tetex-extra
Standards-Version: 3.7.2
XS-Vcs-Svn: https://moonshine.dnsalias.org/svn/arjan-public/debian/frown

Package: frown
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: LALR(k) parser generator for Haskell 98
 Frown is inspired by the parser generator Happy and uses a syntax
 quite simular as the syntax used by Happy. Happy only handles LALR(1)
 grammars while Frown can use more extensive LALR(k) grammars and the
 parsers generated by Frown are also faster than the parsers generated
 by Happy.
 .
 The salient features of Frown are:
   - The generated parsers are time and space efficient. On the
     downside, the parsers are quite large.
   - Frown generates four different types of parsers. As a common
     characteristic, the parsers are genuinely functional
     (ie 'table-free'); the states of the underlying LR automaton are
     encoded as mutually recursive functions. Three output formats use
     a typed stack representation, one format due to Ross Paterson
     (code=stackless) works even without a stack.
   - Encoding states as functions means that each state can be treated
     individually as opposed to a table driven-approach, which
     necessitates a uniform treatment of states. For instance,
     look-ahead is only used when necessary to resolve conflicts.
   - Frown comes with debugging and tracing facilities; the standard
     output format due to Doaitse Swierstra (code=standard) may be
     useful for teaching LR parsing.
   - Common grammatical patterns such as repetition of symbols can be
     captured using rule schemata. There are several predefined rule
     schemata.
   - Terminal symbols are arbitrary variable-free Haskell patterns or
     guards. Both terminal and nonterminal symbols may have an
     arbitrary number of synthesized attributes.
   - Frown comes with extensive documentation; several example grammars
     are included.
 .
 Furthermore, Frown supports the use of monadic lexers, monadic
 semantic actions, precedences and associativity, the generation of
 backtracking parsers, multiple start symbols, error reporting and a
 weak form of error correction.
 .
  Homepage: http://www.informatik.uni-bonn.de/~ralf/frown/index.html
