Source: frown
Maintainer: Debian Haskell Group <pkg-haskell-maintainers@lists.alioth.debian.org>
Uploaders: Joachim Breitner <nomeata@debian.org>
Priority: extra
Section: haskell
Build-Depends: debhelper (>= 9),
 haskell-devscripts (>= 0.10),
 cdbs,
 ghc,
 lhs2tex,
 hevea,
 texlive-generic-recommended,
 texlive-latex-extra,
Standards-Version: 3.9.6
Homepage: http://hackage.haskell.org/package/frown
Vcs-Browser: https://anonscm.debian.org/cgit/pkg-haskell/DHG_packages.git/tree/p/frown
Vcs-Git: git://git.debian.org/git/pkg-haskell/DHG_packages.git
X-Description: LALR(k) parser generator
 Frown is an LALR(k) parser generator for Haskell 98 written in Haskell 98.
 .
 Its salient features are:
    -  The generated parsers are time and space efficient. On the downside, the
       parsers are quite large.
    -  Frown generates four different types of parsers. as a common
       characteristic, the parsers are genuinely functional (ie ‘table-free’);
       the states of the underlying LR automaton are encoded as mutually
       recursive functions. Three output formats use a typed stack
       representation, and one format due to Ross Paterson (code=stackless)
       works even without a stack.
    -  Encoding states as functions means that each state can be treated
       individually as opposed to a table-driven approach, which necessitates a
       uniform treatment of states. For instance, look-ahead is only used when
       necessary to resolve conflicts.
    -  Frown comes with debugging and tracing facilities; the standard output
       format due to Doaitse Swierstra (code=standard) may be useful for
       teaching LR parsing.
    -  Common grammatical patterns such as repetition of symbols can be
       captured using rule schemata. There are several predefined rule
       schemata.
    -  Terminal symbols are arbitrary variable-free Haskell patterns or guards.
       Both terminal and nonterminal symbols may have an arbitrary number of
       synthesized attributes.
    -  Frown comes with extensive documentation; several example grammars are
       included. Furthermore, Frown supports the use of monadic lexers, monadic
       semantic actions, precedences, and associativity, the generation of
       backtracking parsers, multiple start symbols, error reporting, and a
       weak form of error correction.

Package: frown
Architecture: any
Section: misc
Depends: ${shlibs:Depends}, ${haskell:Depends}, ${misc:Depends},
Recommends: ${haskell:Recommends}, frown-doc (= ${source:Version})
Suggests: ${haskell:Suggests},
Conflicts: ${haskell:Conflicts},
Provides: ${haskell:Provides},
Multi-Arch: foreign
Description: ${haskell:ShortDescription}
 ${haskell:LongDescription}

Package: frown-doc
Architecture: all
Section: doc
Depends: ${shlibs:Depends}, ${misc:Depends}
Suggests: doc-base
Description: ${haskell:ShortDescription} -- documentation
 ${haskell:LongDescription}
