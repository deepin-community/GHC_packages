From 3758da0850575dba66fbac9a2ca45ee5ef7fc3c3 Mon Sep 17 00:00:00 2001
From: Joey Hess <joeyh@joeyh.name>
Date: Sun, 22 Apr 2018 14:34:27 -0400
Subject: [PATCH] update to conduit-1.3 (untested)

The new conduit removed ResumableSource, replacing it with
SealedConduitT. Rather than use that, changed to using runConduit and
.| where it used to use $$+-
I *think* that will behave the same, but have not tested it.

Note that the type of HTTPResponseConsumer changed accordingly;
this may be an API change for aws and need a major version bump.

The removal of ResumableSource required the removal of this line from
s3ResponseConsumer:
            C.closeResumableSource (HTTP.responseBody resp)
So there's a potential for a change to the http response resource
lifetime having been introduced by these changes. I don't understand
conduit well enough to say if this is really a problem.
See this blog post for background:
https://www.snoyman.com/blog/2018/01/drop-conduits-finalizers

Also, added a dependency on exceptions, since ResourceT
no longer has a MonadBaseControl instance.
---
 Aws/Aws.hs                   |  4 ++--
 Aws/Core.hs                  | 22 ++++++----------------
 Aws/DynamoDb/Core.hs         |  2 +-
 Aws/S3/Commands/GetObject.hs |  5 +++--
 Aws/S3/Core.hs               |  5 ++---
 Aws/Sqs/Core.hs              |  5 +++--
 aws.cabal                    | 11 ++++++-----
 7 files changed, 23 insertions(+), 31 deletions(-)

--- a/Aws/Aws.hs
+++ b/Aws/Aws.hs
@@ -35,8 +35,8 @@
 
 import           Aws.Core
 import           Control.Applicative
-import qualified Control.Exception.Lifted     as E
 import           Control.Monad
+import qualified Control.Monad.Catch          as E
 import           Control.Monad.IO.Class
 import           Control.Monad.Trans
 import           Control.Monad.Trans.Resource
@@ -91,7 +91,7 @@
 baseConfiguration = liftIO $ do
   cr <- loadCredentialsDefault
   case cr of
-    Nothing -> E.throw $ NoCredentialsException "could not locate aws credentials"
+    Nothing -> E.throwM $ NoCredentialsException "could not locate aws credentials"
     Just cr' -> return Configuration {
                       timeInfo = Timestamp
                     , credentials = cr'
--- a/Aws/Core.hs
+++ b/Aws/Core.hs
@@ -115,7 +115,7 @@
 import qualified Data.ByteString.Lazy     as L
 import qualified Data.ByteString.UTF8     as BU
 import           Data.Char
-import           Data.Conduit             (($$+-))
+import           Data.Conduit             ((.|))
 import qualified Data.Conduit             as C
 #if MIN_VERSION_http_conduit(2,2,0)
 import qualified Data.Conduit.Binary      as CB
@@ -195,7 +195,7 @@
 tellMetadataRef r m = modifyIORef r (`mappend` m)
 
 -- | A full HTTP response parser. Takes HTTP status, response headers, and response body.
-type HTTPResponseConsumer a = HTTP.Response (C.ResumableSource (ResourceT IO) ByteString)
+type HTTPResponseConsumer a = HTTP.Response (C.ConduitM () ByteString (ResourceT IO) ())
                               -> ResourceT IO a
 
 -- | Class for types that AWS HTTP responses can be parsed into.
@@ -217,7 +217,7 @@
 instance ResponseConsumer r (HTTP.Response L.ByteString) where
     type ResponseMetadata (HTTP.Response L.ByteString) = ()
     responseConsumer _ _ _ resp = do
-        bss <- HTTP.responseBody resp $$+- CL.consume
+        bss <- C.runConduit $ HTTP.responseBody resp .| CL.consume
         return resp
             { HTTP.responseBody = L.fromChunks bss
             }
@@ -875,23 +875,13 @@
 instance E.Exception NoCredentialsException
 
 -- | A helper to throw an 'HTTP.StatusCodeException'.
-throwStatusCodeException :: HTTP.Request
-                         -> HTTP.Response (C.ResumableSource (ResourceT IO) ByteString)
-                         -> ResourceT IO a
-#if MIN_VERSION_http_conduit(2,2,0)
+throwStatusCodeException :: MonadThrow m => HTTP.Request -> HTTP.Response (C.ConduitM () ByteString m ()) -> m a
 throwStatusCodeException req resp = do
     let resp' = fmap (const ()) resp
     -- only take first 10kB of error response
-    body <- HTTP.responseBody resp C.$$+- CB.take (10*1024)
+    body <- C.runConduit $ HTTP.responseBody resp .| CB.take (10*1024)
     let sce = HTTP.StatusCodeException resp' (L.toStrict body)
     throwM $ HTTP.HttpExceptionRequest req sce
-#else
-throwStatusCodeException _req resp = do
-    let cookies = HTTP.responseCookieJar resp
-        headers = HTTP.responseHeaders   resp
-        status  = HTTP.responseStatus    resp
-    throwM $ HTTP.StatusCodeException status headers cookies
-#endif
 
 -- | A specific element (case-insensitive, ignoring namespace - sadly necessary), extracting only the textual contents.
 elContent :: T.Text -> Cursor -> [T.Text]
@@ -939,7 +929,7 @@
     -> IORef m
     -> HTTPResponseConsumer a
 xmlCursorConsumer parse metadataRef res
-    = do doc <- HTTP.responseBody res $$+- XML.sinkDoc XML.def
+    = do doc <- C.runConduit $ HTTP.responseBody res .| XML.sinkDoc XML.def
          let cursor = Cu.fromDocument doc
          let Response metadata x = parse cursor
          liftIO $ tellMetadataRef metadataRef metadata
--- a/Aws/DynamoDb/Core.hs
+++ b/Aws/DynamoDb/Core.hs
@@ -895,7 +895,7 @@
 -------------------------------------------------------------------------------
 ddbResponseConsumer :: A.FromJSON a => IORef DdbResponse -> HTTPResponseConsumer a
 ddbResponseConsumer ref resp = do
-    val <- HTTP.responseBody resp $$+- sinkParser (A.json' <* AttoB.endOfInput)
+    val <- runConduit $ HTTP.responseBody resp .| sinkParser (A.json' <* AttoB.endOfInput)
     case statusCode of
       200 -> rSuccess val
       _   -> rError val
--- a/Aws/S3/Commands/GetObject.hs
+++ b/Aws/S3/Commands/GetObject.hs
@@ -11,6 +11,7 @@
 import qualified Data.ByteString.Char8 as B8
 import qualified Data.ByteString.Lazy  as L
 import qualified Data.Conduit          as C
+import           Data.Conduit ((.|))
 import qualified Data.Conduit.List     as CL
 import           Data.Maybe
 import qualified Data.Text             as T
@@ -44,7 +45,7 @@
 data GetObjectResponse
     = GetObjectResponse {
         gorMetadata :: ObjectMetadata,
-        gorResponse :: HTTP.Response (C.ResumableSource (ResourceT IO) B8.ByteString)
+        gorResponse :: HTTP.Response (C.ConduitM () B8.ByteString (ResourceT IO) ())
       }
 
 data GetObjectMemoryResponse
@@ -96,7 +97,7 @@
 instance AsMemoryResponse GetObjectResponse where
     type MemoryResponse GetObjectResponse = GetObjectMemoryResponse
     loadToMemory (GetObjectResponse om x) = do
-        bss <- HTTP.responseBody x C.$$+- CL.consume
+        bss <- C.runConduit $ HTTP.responseBody x .| CL.consume
         return $ GetObjectMemoryResponse om x
             { HTTP.responseBody = L.fromChunks bss
             }
--- a/Aws/S3/Core.hs
+++ b/Aws/S3/Core.hs
@@ -7,7 +7,7 @@
 import           Control.Monad.IO.Class
 import           Control.Monad.Trans.Resource   (MonadThrow, throwM)
 import           Data.Char                      (isAscii, isAlphaNum, toUpper, ord)
-import           Data.Conduit                   (($$+-))
+import           Data.Conduit                   ((.|))
 import           Data.Function
 import           Data.Functor                   ((<$>))
 import           Data.IORef
@@ -418,7 +418,6 @@
   where inner' resp =
           do
             !res <- inner resp
-            C.closeResumableSource (HTTP.responseBody resp)
             return res
 
 s3BinaryResponseConsumer :: HTTPResponseConsumer a
@@ -444,7 +443,7 @@
 
 s3ErrorResponseConsumer :: HTTPResponseConsumer a
 s3ErrorResponseConsumer resp
-    = do doc <- HTTP.responseBody resp $$+- XML.sinkDoc XML.def
+    = do doc <- C.runConduit $ HTTP.responseBody resp .| XML.sinkDoc XML.def
          let cursor = Cu.fromDocument doc
          liftIO $ case parseError cursor of
            Right err      -> throwM err
--- a/Aws/Sqs/Core.hs
+++ b/Aws/Sqs/Core.hs
@@ -11,7 +11,8 @@
 import           Control.Monad.Trans.Resource   (MonadThrow, throwM)
 import qualified Data.ByteString                as B
 import qualified Data.ByteString.Char8          as BC
-import           Data.Conduit                   (($$+-))
+import qualified Data.Conduit
+import           Data.Conduit                   ((.|))
 import           Data.IORef
 import           Data.List
 import           Data.Maybe
@@ -248,7 +249,7 @@
 
 sqsErrorResponseConsumer :: HTTPResponseConsumer a
 sqsErrorResponseConsumer resp
-    = do doc <- HTTP.responseBody resp $$+- XML.sinkDoc XML.def
+    = do doc <- Data.Conduit.runConduit $ HTTP.responseBody resp .| XML.sinkDoc XML.def
          let cursor = Cu.fromDocument doc
          liftIO $ case parseError cursor of
            Right err     -> throwM err
--- a/aws.cabal
+++ b/aws.cabal
@@ -123,22 +123,23 @@
                        bytestring           >= 0.9     && < 0.11,
                        case-insensitive     >= 0.2     && < 1.3,
                        cereal               >= 0.3     && < 0.6,
-                       conduit              >= 1.1     && < 1.3,
-                       conduit-extra        >= 1.1     && < 1.3,
+                       conduit              >= 1.3     && < 1.4,
+                       conduit-extra        >= 1.3     && < 1.4,
                        containers           >= 0.4,
                        cryptonite           >= 0.11,
                        data-default         >= 0.5.3   && < 0.8,
                        directory            >= 1.0     && < 2.0,
                        filepath             >= 1.1     && < 1.5,
-                       http-conduit         >= 2.1     && < 2.4,
+                       http-conduit         >= 2.3     && < 2.4,
                        http-types           >= 0.7     && < 1.0,
                        lifted-base          >= 0.1     && < 0.3,
                        memory,
                        monad-control        >= 0.3,
+                       exceptions           >= 0.8     && < 0.11,
                        mtl                  == 2.*,
                        network              == 2.*,
                        old-locale           == 1.*,
-                       resourcet            >= 1.1     && < 1.2,
+                       resourcet            >= 1.2     && < 1.3,
                        safe                 >= 0.3     && < 0.4,
                        scientific           >= 0.3,
                        tagged               >= 0.7     && < 0.9,
@@ -148,7 +149,7 @@
                        unordered-containers >= 0.2,
                        utf8-string          >= 0.3     && < 1.1,
                        vector               >= 0.10,
-                       xml-conduit          >= 1.2     && <2.0
+                       xml-conduit          >= 1.8     && <2.0
  
   if !impl(ghc >= 7.6)
     Build-depends: ghc-prim
