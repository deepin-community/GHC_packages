Description: Add Eq instance constraint to semiring class
  Num no longer implies Eq, so we need this now.
Author: Iain Lane <laney@debian.org>
Forwarded: https://github.com/sebfisch/haskell-regexp/pull/22

Index: haskell-weighted-regexp/src/Data/Semiring.hs
===================================================================
--- haskell-weighted-regexp.orig/src/Data/Semiring.hs	2012-02-14 23:14:42.000000000 +0000
+++ haskell-weighted-regexp/src/Data/Semiring.hs	2012-02-14 23:17:04.389795495 +0000
@@ -82,5 +82,5 @@
 instance Show a => Show (Numeric a) where
   show = show . getNumeric

-instance Num a => Semiring (Numeric a) where
+instance (Eq a, Num a) => Semiring (Numeric a) where
   zero = 0; one = 1; (.+.) = (+); (.*.) = (*)
Index: haskell-weighted-regexp/src/Text/RegExp/Data.hs
===================================================================
--- haskell-weighted-regexp.orig/src/Text/RegExp/Data.hs	2012-02-14 23:14:42.000000000 +0000
+++ haskell-weighted-regexp/src/Text/RegExp/Data.hs	2012-02-14 23:17:04.389795495 +0000
@@ -35,7 +35,7 @@
 instance Weight c c Bool where
   symWeight = defaultSymWeight

-instance Num a => Weight c c (Numeric a) where
+instance (Eq a, Num a) => Weight c c (Numeric a) where
   symWeight = defaultSymWeight

 weighted :: Weight a b w => RegW w a -> RegW w b
Index: haskell-weighted-regexp/src/Text/RegExp/Matching.hs
===================================================================
--- haskell-weighted-regexp.orig/src/Text/RegExp/Matching.hs	2011-08-15 05:49:35.000000000 +0100
+++ haskell-weighted-regexp/src/Text/RegExp/Matching.hs	2012-02-14 23:18:54.297493176 +0000
@@ -30,7 +30,7 @@
 -- Computes in how many ways a word can be matched against a regular
 -- expression.
 --
-matchingCount :: Num a => RegExp c -> [c] -> a
+matchingCount :: (Eq a, Num a) => RegExp c -> [c] -> a
 matchingCount r = getNumeric . fullMatch r

 {-# SPECIALIZE matchingCount :: RegExp c -> [c] -> Int #-}
@@ -50,7 +50,7 @@

 {-# SPECIALIZE fullMatch :: RegExp c -> [c] -> Bool #-}
 {-# SPECIALIZE fullMatch :: RegExp c -> [c] -> Numeric Int #-}
-{-# SPECIALIZE fullMatch :: Num a => RegExp c -> [c] -> Numeric a #-}
+{-# SPECIALIZE fullMatch :: (Eq a, Num a) => RegExp c -> [c] -> Numeric a #-}
 {-# SPECIALIZE fullMatch :: RegExp c -> [(Int,c)] -> Leftmost #-}
 {-# SPECIALIZE fullMatch :: RegExp c -> [c] -> Longest #-}
 {-# SPECIALIZE fullMatch :: RegExp c -> [(Int,c)] -> LeftLong #-}
@@ -67,7 +67,7 @@

 {-# SPECIALIZE partialMatch :: RegExp c -> [c] -> Bool #-}
 {-# SPECIALIZE partialMatch :: RegExp c -> [c] -> Numeric Int #-}
-{-# SPECIALIZE partialMatch :: Num a => RegExp c -> [c] -> Numeric a #-}
+{-# SPECIALIZE partialMatch :: (Eq a, Num a) => RegExp c -> [c] -> Numeric a #-}
 {-# SPECIALIZE partialMatch :: RegExp c -> [(Int,c)] -> Leftmost #-}
 {-# SPECIALIZE partialMatch :: RegExp c -> [c] -> Longest #-}
 {-# SPECIALIZE partialMatch :: RegExp c -> [(Int,c)] -> LeftLong #-}
@@ -78,7 +78,7 @@

 {-# SPECIALIZE matchW :: RegW Bool c -> [c] -> Bool #-}
 {-# SPECIALIZE matchW :: RegW (Numeric Int) c -> [c] -> Numeric Int #-}
-{-# SPECIALIZE matchW :: Num a => RegW (Numeric a) c -> [c] -> Numeric a #-}
+{-# SPECIALIZE matchW :: (Eq a, Num a) => RegW (Numeric a) c -> [c] -> Numeric a #-}
 {-# SPECIALIZE matchW :: RegW Leftmost (Int,c) -> [(Int,c)] -> Leftmost #-}
 {-# SPECIALIZE matchW :: RegW Longest c -> [c] -> Longest #-}
 {-# SPECIALIZE matchW :: RegW LeftLong (Int,c) -> [(Int,c)] -> LeftLong #-}
