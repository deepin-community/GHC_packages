Index: b/src/Text/XML/HaXml/DtdToHaskell/TypeDef.hs
===================================================================
--- a/src/Text/XML/HaXml/DtdToHaskell/TypeDef.hs
+++ b/src/Text/XML/HaXml/DtdToHaskell/TypeDef.hs
@@ -22,6 +22,8 @@ import Data.Char (isLower, isUpper, toLo
 import Data.List (intersperse)
 import Text.PrettyPrint.HughesPJ
 
+import Prelude hiding ((<>))
+
 
 ---- Internal representation for typedefs ----
 
Index: b/src/Text/XML/HaXml/DtdToHaskell/Instance.hs
===================================================================
--- a/src/Text/XML/HaXml/DtdToHaskell/Instance.hs
+++ b/src/Text/XML/HaXml/DtdToHaskell/Instance.hs
@@ -7,6 +7,8 @@ import Data.List (intersperse)
 import Text.XML.HaXml.DtdToHaskell.TypeDef
 import Text.PrettyPrint.HughesPJ
 
+import Prelude hiding ((<>))
+
 -- | Convert typedef to appropriate instance declaration, either @XmlContent@,
 --   @XmlAttributes@, or @XmlAttrType@.
 mkInstance :: TypeDef -> Doc
Index: b/src/Text/XML/HaXml/Schema/XSDTypeModel.hs
===================================================================
--- a/src/Text/XML/HaXml/Schema/XSDTypeModel.hs
+++ b/src/Text/XML/HaXml/Schema/XSDTypeModel.hs
@@ -2,7 +2,8 @@ module Text.XML.HaXml.Schema.XSDTypeMode
   ( module Text.XML.HaXml.Schema.XSDTypeModel
   ) where
 
-import Data.Monoid hiding (Any)
+import Data.Monoid hiding (Any, (<>))
+import Data.Semigroup hiding (Any)
 import Text.XML.HaXml.Types      (Name,Namespace,QName)
 
 data Schema        = Schema
@@ -297,6 +298,9 @@ instance Monoid Annotation where
   _                 `mappend` (Documentation e) = Documentation e
   ann               `mappend` _                 = ann          
 
+instance Semigroup Annotation where
+  (<>) = mappend
+
 -- This instance is pretty unsatisfactory, and is useful only for
 -- building environments involving recursive modules.  The /mappend/
 -- method is left-biased, and the /mempty/ value contains lots of
@@ -305,3 +309,5 @@ instance Monoid Schema where
   mempty        = Schema{ schema_items=[] }
   s `mappend` t = s{ schema_items = schema_items s ++ schema_items t }
 
+instance Semigroup Schema where
+  (<>) = mappend
Index: b/HaXml.cabal
===================================================================
--- a/HaXml.cabal
+++ b/HaXml.cabal
@@ -67,7 +67,7 @@ library
     exposed-modules:
         Text.XML.HaXml.Schema.Schema
   hs-source-dirs: src
-  build-depends: polyparse >= 1.10, filepath
+  build-depends: polyparse >= 1.10, filepath, semigroups
   if flag(splitBase)
     build-depends: base >= 3 && < 6, pretty, random, containers
   else
Index: b/src/Text/XML/HaXml/ByteStringPP.hs
===================================================================
--- a/src/Text/XML/HaXml/ByteStringPP.hs
+++ b/src/Text/XML/HaXml/ByteStringPP.hs
@@ -20,7 +20,7 @@ module Text.XML.HaXml.ByteStringPP
   ,   cp
   ) where
 
-import Prelude hiding (maybe,either,elem,concat)
+import Prelude hiding (maybe,either,elem,concat,(<>))
 import Data.Maybe hiding (maybe)
 import Data.List (intersperse)
 --import Data.ByteString.Lazy hiding (pack,map,head,any,singleton,intersperse,join)
Index: b/src/Text/XML/HaXml/Html/Pretty.hs
===================================================================
--- a/src/Text/XML/HaXml/Html/Pretty.hs
+++ b/src/Text/XML/HaXml/Html/Pretty.hs
@@ -8,7 +8,7 @@ module Text.XML.HaXml.Html.Pretty
   , content
   ) where
 
-import Prelude hiding (maybe,either)
+import Prelude hiding (maybe,either,(<>))
 import Data.Maybe hiding (maybe)
 import Data.List (intersperse)
 import Data.Char (isSpace)
Index: b/src/Text/XML/HaXml/Pretty.hs
===================================================================
--- a/src/Text/XML/HaXml/Pretty.hs
+++ b/src/Text/XML/HaXml/Pretty.hs
@@ -21,7 +21,7 @@ module Text.XML.HaXml.Pretty
   ,   cp
   ) where
 
-import Prelude hiding (maybe,either)
+import Prelude hiding (maybe,either,(<>))
 import Data.Maybe hiding (maybe)
 import Data.List (intersperse)
 --import Char (isSpace)
Index: b/src/Text/XML/HaXml/Schema/PrettyHaskell.hs
===================================================================
--- a/src/Text/XML/HaXml/Schema/PrettyHaskell.hs
+++ b/src/Text/XML/HaXml/Schema/PrettyHaskell.hs
@@ -20,6 +20,8 @@ import Data.List (intersperse,notElem,in
 import Data.Maybe (isJust,fromJust,fromMaybe,catMaybes)
 import Data.Char (toLower)
 
+import Prelude hiding ((<>))
+
 -- | Vertically pretty-print a list of things, with open and close brackets,
 --   and separators.
 ppvList :: String -> String -> String -> (a->Doc) -> [a] -> Doc
Index: b/src/Text/XML/HaXml/Schema/PrettyHsBoot.hs
===================================================================
--- a/src/Text/XML/HaXml/Schema/PrettyHsBoot.hs
+++ b/src/Text/XML/HaXml/Schema/PrettyHsBoot.hs
@@ -19,6 +19,8 @@ import Text.PrettyPrint.HughesPJ as PP
 import Data.List (intersperse,notElem,inits)
 import Data.Maybe (isJust,fromJust,catMaybes)
 
+import Prelude hiding ((<>))
+
 -- | Vertically pretty-print a list of things, with open and close brackets,
 --   and separators.
 ppvList :: String -> String -> String -> (a->Doc) -> [a] -> Doc
Index: b/src/Text/XML/HaXml/Schema/TypeConversion.hs
===================================================================
--- a/src/Text/XML/HaXml/Schema/TypeConversion.hs
+++ b/src/Text/XML/HaXml/Schema/TypeConversion.hs
@@ -538,6 +538,9 @@ consolidate (Occurs min max) (UnorderedM
 consolidate (Occurs min max) (UnorderedMaxLength,_,n) =
              Occurs min (Just (read n))
 
+instance Semigroup Occurs where
+  (<>) = mappend
+
 instance Monoid Occurs where
     mempty = Occurs Nothing Nothing
     (Occurs Nothing  Nothing)  `mappend` o  = o
Index: b/src/Text/XML/HaXml/ShowXmlLazy.hs
===================================================================
--- a/src/Text/XML/HaXml/ShowXmlLazy.hs
+++ b/src/Text/XML/HaXml/ShowXmlLazy.hs
@@ -5,7 +5,7 @@ import Text.XML.HaXml.Namespaces
 import Text.XML.HaXml.TypeMapping -- (toHType, toDTD, Tuple(), Defined, showHType)
 
 import qualified Text.XML.HaXml.XmlContent as X
-import Prelude hiding (maybe,either)
+import Prelude hiding (maybe,either,(<>))
 import Data.Maybe hiding (maybe)
 import Data.List
 
