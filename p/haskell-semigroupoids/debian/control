Source: haskell-semigroupoids
Maintainer: Debian Haskell Group <pkg-haskell-maintainers@lists.alioth.debian.org>
Uploaders: Iulian Udrea <iulian@linux.com>
Priority: extra
Section: haskell
Build-Depends: debhelper (>= 9),
 haskell-devscripts (>= 0.13),
 cdbs,
 ghc (>= 8),
 ghc-prof,
 libghc-base-orphans-dev (>= 0.3),
 libghc-base-orphans-dev (<< 1),
 libghc-base-orphans-prof,
 libghc-bifunctors-dev (>= 5),
 libghc-bifunctors-dev (<< 6),
 libghc-bifunctors-prof,
 libghc-comonad-dev (>= 4.2.6),
 libghc-comonad-dev (<< 6),
 libghc-comonad-prof,
 libghc-contravariant-dev (>= 0.2.0.1),
 libghc-contravariant-dev (<< 2),
 libghc-contravariant-prof,
 libghc-distributive-dev (>= 0.2.2),
 libghc-distributive-dev (<< 1),
 libghc-distributive-prof,
 libghc-semigroups-dev (>= 0.8.3.1),
 libghc-semigroups-dev (<< 1),
 libghc-semigroups-prof,
 libghc-tagged-dev (>= 0.7.3),
 libghc-tagged-dev (<< 1),
 libghc-tagged-prof,
 libghc-transformers-compat-dev (>= 0.5),
 libghc-transformers-compat-dev (<< 0.6),
 libghc-transformers-compat-prof,
Build-Depends-Indep: ghc-doc,
 libghc-base-orphans-doc,
 libghc-bifunctors-doc,
 libghc-comonad-doc,
 libghc-contravariant-doc,
 libghc-distributive-doc,
 libghc-semigroups-doc,
 libghc-tagged-doc,
 libghc-transformers-compat-doc,
Standards-Version: 3.9.8
Homepage: http://github.com/ekmett/semigroupoids
Vcs-Browser: https://anonscm.debian.org/cgit/pkg-haskell/DHG_packages.git/tree/p/haskell-semigroupoids
Vcs-Git: https://anonscm.debian.org/git/pkg-haskell/DHG_packages.git

Package: libghc-semigroupoids-dev
Architecture: any
Depends: ${haskell:Depends},
 ${shlibs:Depends},
 ${misc:Depends},
Recommends: ${haskell:Recommends},
Suggests: ${haskell:Suggests},
Provides: ${haskell:Provides},
Description: Haskell 98 semigroupoids: Category sans id${haskell:ShortBlurb}
 A Semigroupoid is a Category without the requirement of identity arrows for
 every object in the category.
 .
 When working with comonads you often have the <*> portion of an Applicative,
 but not the pure. This was captured in Uustalu and Vene's "Essence of Dataflow
 Programming" in the form of the ComonadZip class in the days before
 Applicative. Apply provides a weaker invariant, but for the comonads used for
 data flow programming (found in the streams package), this invariant is
 preserved. Applicative function composition forms a semigroupoid.
 .
 ${haskell:Blurb}

Package: libghc-semigroupoids-prof
Architecture: any
Depends: ${haskell:Depends},
 ${misc:Depends},
Recommends: ${haskell:Recommends},
Suggests: ${haskell:Suggests},
Provides: ${haskell:Provides},
Description: Haskell 98 semigroupoids: Category sans id${haskell:ShortBlurb}
 A Semigroupoid is a Category without the requirement of identity arrows for
 every object in the category.
 .
 When working with comonads you often have the <*> portion of an Applicative,
 but not the pure. This was captured in Uustalu and Vene's "Essence of Dataflow
 Programming" in the form of the ComonadZip class in the days before
 Applicative. Apply provides a weaker invariant, but for the comonads used for
 data flow programming (found in the streams package), this invariant is
 preserved. Applicative function composition forms a semigroupoid.
 .
 ${haskell:Blurb}

Package: libghc-semigroupoids-doc
Architecture: all
Section: doc
Depends: ${misc:Depends},
 ${haskell:Depends},
Recommends: ${haskell:Recommends},
Suggests: ${haskell:Suggests},
Description: Haskell 98 semigroupoids: Category sans id${haskell:ShortBlurb}
 A Semigroupoid is a Category without the requirement of identity arrows for
 every object in the category.
 .
 When working with comonads you often have the <*> portion of an Applicative,
 but not the pure. This was captured in Uustalu and Vene's "Essence of Dataflow
 Programming" in the form of the ComonadZip class in the days before
 Applicative. Apply provides a weaker invariant, but for the comonads used for
 data flow programming (found in the streams package), this invariant is
 preserved. Applicative function composition forms a semigroupoid.
 .
 ${haskell:Blurb}
