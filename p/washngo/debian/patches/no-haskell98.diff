--- a/WashNGo.cabal
+++ b/WashNGo.cabal
@@ -21,9 +21,9 @@
 --  location: http://code.haskell.org/WASH/

 Library
-  Build-Depends: base < 5, regex-compat, haskell98, parsec >= 3
+  Build-Depends: base < 5, regex-compat, parsec >= 3
   Extensions: ForeignFunctionInterface
-  build-depends: containers
+  build-depends: array, containers, old-locale, old-time, random
   Exposed-Modules:
           WASH.CGI.AbstractSelector
           WASH.CGI.BaseCombinators
--- a/washparser/hs/WASHClean.hs
+++ b/washparser/hs/WASHClean.hs
@@ -1,7 +1,6 @@
 module WASHClean where

-import Char
-
+import Data.Char (isSpace)
 import WASHData

 data CM a = CM ([String] -> a)
--- a/washparser/hs/WASHExpression.hs
+++ b/washparser/hs/WASHExpression.hs
@@ -1,7 +1,7 @@
 module WASHExpression where

-import List
-import Monad
+import Control.Monad (when, mplus, unless)
+import Data.List (isPrefixOf)

 import WASHFlags
 import qualified WASHUtil
--- a/WASH/CGI/AbstractSelector.hs
+++ b/WASH/CGI/AbstractSelector.hs
@@ -2,6 +2,9 @@
   -- the public interface
   -- ( as_rows, as_cols, table_io, getText, selectionGroup, selectionButton, selectionDisplay)
 where
+import Data.Char (isSpace)
+import Data.List ((\\))
+import Data.Maybe (fromMaybe, isJust)

 import WASH.CGI.BaseCombinators (unsafe_io, once)
 import WASH.CGI.CGIInternals (HTMLField, INVALID, ValidationError (..))
@@ -10,11 +13,6 @@
 import WASH.CGI.RawCGIInternal hiding (CGIEnv (..))
 import WASH.Utility.JavaScript

-import Char
-import List ((\\))
-import Maybe
-
-
 -- |abstract table (twodimensional)
 data AT =
     AT { as_raw :: [[String]]
--- a/WASH/CGI/ContentType.hs
+++ b/WASH/CGI/ContentType.hs
@@ -1,8 +1,8 @@
 -- © 2001, 2002 Peter Thiemann
 module WASH.CGI.ContentType where

-import Char
-import List
+import Data.Char (toLower)
+import Data.List (isSuffixOf)

 -- |tries to derive a MIME content type from a file name
 guessContentType :: String -> String
--- a/WASH/CGI/Fields.hs
+++ b/WASH/CGI/Fields.hs
@@ -1,8 +1,8 @@
 -- © 2002 Peter Thiemann
 module WASH.CGI.Fields where
+import Data.Char (isDigit, isSpace, isUpper, isLower, isPrint, isAlpha, isAlphaNum, ord)
+import Data.List (isPrefixOf, isSuffixOf, tails)

-import Char
-import List
 import WASH.Utility.ISO8601
 import WASH.Utility.SimpleParser as SimpleParser
 import WASH.CGI.CGITypes
--- a/WASH/CGI/HTTP.hs
+++ b/WASH/CGI/HTTP.hs
@@ -1,6 +1,6 @@
 module WASH.CGI.HTTP where

-import Char
+import Data.Char (isSpace, isAlphaNum)

 data Method =
     OPTIONS
--- a/WASH/CGI/PPM.hs
+++ b/WASH/CGI/PPM.hs
@@ -1,7 +1,7 @@
 -- © 2001 Peter Thiemann
 module WASH.CGI.PPM where

-import Char
+import Data.Char (isSpace, chr, ord)

 data Pixmap =
      Pixmap	{ width :: Int
--- a/WASH/CGI/RawCGIInternal.hs
+++ b/WASH/CGI/RawCGIInternal.hs
@@ -4,14 +4,14 @@
   (module WASH.CGI.RawCGITypes, module WASH.CGI.RawCGIInternal)
   where
 -- (CGIParameter, CGIParameters, start, assocParm, assoc)
+import Control.OldException (try)
+import Data.Char (isSpace, chr, ord, toLower, toUpper)
+import Data.List (find)
+import Data.Maybe (fromJust, listToMaybe)
+import System.Environment (getArgs)
+import System.IO (Handle, stdin, stdout, openFile, IOMode(ReadMode), hFileSize, hSeek, SeekMode(AbsoluteSeek), hGetContents)
+import System.Random (randoms, randomRs, mkStdGen, randomRIO, getStdGen)

-import Array
-import Char
-import IO
-import List
-import Maybe
-import Random
-import System
 import WASH.Utility.Auxiliary
 import WASH.Utility.Unique
 import qualified WASH.Utility.URLCoding as URLCoding
--- a/WASH/CGI/StateItem.hs
+++ b/WASH/CGI/StateItem.hs
@@ -1,8 +1,7 @@
 -- © 2002 Peter Thiemann
 module WASH.CGI.StateItem where

-import Char
-
+import Data.Char (isSpace)
 --
 -- |type of handles to a PE of type @a@
 data T a = T String Int | Tvirtual { tvirtual :: a }
--- a/WASH/HTML/HTMLBase.hs
+++ b/WASH/HTML/HTMLBase.hs
@@ -14,7 +14,7 @@
 -}
 where

-import Char
+import Data.Char (isSpace, chr, ord)

 data BT = STATIC | DYNAMIC | TOPLEVEL

--- a/WASH/HTML/HTMLTypedBase.hs
+++ b/WASH/HTML/HTMLTypedBase.hs
@@ -4,7 +4,8 @@
   (module WASH.HTML.HTMLBase, module WASH.HTML.HTMLTypedBase)
   where

-import Char
+import Data.Char (toLower)
+
 import WASH.HTML.HTMLBase

 -- typed layer
--- a/WASH/HTML/HTMLTypedBase98.hs
+++ b/WASH/HTML/HTMLTypedBase98.hs
@@ -3,7 +3,8 @@
   (module WASH.HTML.HTMLBase, module WASH.HTML.HTMLTypedBase98)
   where

-import Char
+import Data.Char (toLower)
+
 import WASH.HTML.HTMLBase

 -- typed layer
--- a/WASH/Mail/MIME.hs
+++ b/WASH/Mail/MIME.hs
@@ -2,11 +2,9 @@
 module WASH.Mail.MIME where
 -- RFC 2045
 -- RFC 2046
-
-import Char
-import IO
-import Monad
-import Random
+import Control.Monad (when)
+import System.Random (getStdGen, randomRs)
+import System.IO (hPutStr, stdout, Handle)

 import qualified WASH.Utility.Base64 as Base64
 import qualified WASH.Mail.ContentDisposition as CD
--- a/WASH/Mail/MailParser.hs
+++ b/WASH/Mail/MailParser.hs
@@ -1,11 +1,10 @@
 module WASH.Mail.MailParser where

+import Data.Char (chr, toLower)
+import Data.List (isPrefixOf)
+import Data.Maybe (fromMaybe)
 -- see RFC 2822
 -- TODO: check against their definition of token
-import Char
-import List
-import Maybe
---
 import Text.ParserCombinators.Parsec
 --
 import qualified WASH.Utility.Base64 as Base64
--- a/WASH/Mail/RFC2822.hs
+++ b/WASH/Mail/RFC2822.hs
@@ -1,7 +1,7 @@
 module WASH.Mail.RFC2822 where

-import Char
---
+import Data.Char (digitToInt)
+
 import Text.ParserCombinators.Parsec

 crLf = try (string "\n\r" <|> string "\r\n") <|> string "\n" <|> string "\r"
--- a/WASH/Utility/Base32.hs
+++ b/WASH/Utility/Base32.hs
@@ -4,9 +4,8 @@

 module WASH.Utility.Base32 (encode, decode) where

-import Bits
-import Char
-import List
+import Data.Bits (shiftL, shiftR, (.&.))
+import Data.Char (ord, chr)

 encode :: String -> String
 encode = encBase32
--- a/WASH/Utility/Base64.hs
+++ b/WASH/Utility/Base64.hs
@@ -6,10 +6,8 @@
        )
        where

-import Array
-import Char
-
---
+import Data.Array (array, (!))
+import Data.Char (chr, ord)
 -- |Yields encoded input cropped to lines of less than 76 characters. Directly
 -- usable as email body.
 encode :: String -> String
--- a/WASH/Utility/Hex.hs
+++ b/WASH/Utility/Hex.hs
@@ -1,8 +1,8 @@
 -- © 2001, 2003 Peter Thiemann
 module WASH.Utility.Hex where

-import Array
-import Char
+import Data.Array (array, (!))
+import Data.Char (chr)

 hexdigit :: Int -> Char
 hexdigit i = hexdigits ! i
--- a/WASH/Utility/ISO8601.hs
+++ b/WASH/Utility/ISO8601.hs
@@ -1,11 +1,10 @@
 -- © 2002 Peter Thiemann
 module WASH.Utility.ISO8601 where

-import Char
-import Monad
-import Time
-
+import Control.Monad (liftM)
+import Data.Char (digitToInt)
 import System.IO.Unsafe
+import System.Time (TimeDiff(..), addToClockTime, getClockTime, toCalendarTime, toClockTime, CalendarTime(..), ClockTime(..), Month(..), Day(..))

 import WASH.Utility.IntToString
 import WASH.Utility.SimpleParser
--- a/WASH/Utility/IntToString.hs
+++ b/WASH/Utility/IntToString.hs
@@ -1,7 +1,7 @@
 -- © 2002 Peter Thiemann
 module WASH.Utility.IntToString where

-import Char
+import Data.Char (chr, ord)

 intToString ndigits i =
   let g x = h $ divMod x 10
--- a/WASH/Utility/JavaScript.hs
+++ b/WASH/Utility/JavaScript.hs
@@ -1,8 +1,7 @@
 -- © 2003 Peter Thiemann
 module WASH.Utility.JavaScript where

-import Char
-
+import Data.Char (isPrint, ord)
 import WASH.Utility.Hex

 jsShow :: String -> String
--- a/WASH/Utility/QuotedPrintable.hs
+++ b/WASH/Utility/QuotedPrintable.hs
@@ -4,7 +4,7 @@
        -- deprecated: encode_quoted, encode_quoted', decode_quoted
        ) where

-import Char
+import Data.Char (chr, ord)
 import WASH.Utility.Hex

 encode, encode', decode :: String -> String
--- a/WASH/Utility/RFC2047.hs
+++ b/WASH/Utility/RFC2047.hs
@@ -1,8 +1,8 @@
 -- © 2003 Peter Thiemann
 module WASH.Utility.RFC2047 where
 -- decoding of header fields
-import Char
-import List
+import Data.Char (chr, ord, toUpper)
+import Data.List ((\\))

 import qualified WASH.Utility.Base64 as Base64
 import qualified WASH.Utility.QuotedPrintable as QuotedPrintable
--- a/WASH/Utility/RFC2279.hs
+++ b/WASH/Utility/RFC2279.hs
@@ -11,9 +11,7 @@
   0400 0000-7FFF FFFF   1111110x 10xxxxxx ... 10xxxxxx
 -}
 module WASH.Utility.RFC2279 (encode, decode) where
-
-import Char
-
+import Data.Char (chr, ord)

 -- |maps Unicode string to list of octets
 encode :: String -> String
--- a/WASH/Utility/SHA1.hs
+++ b/WASH/Utility/SHA1.hs
@@ -4,9 +4,9 @@

 module WASH.Utility.SHA1 (sha1, sha1_size) where

-import Char
-import Bits
-import Word
+import Data.Bits (shiftL, shiftR, (.&.), (.|.), complement, xor)
+import Data.Char (chr, ord)
+import Data.Word (Word16, Word32)

 type ABCDE = (Word32, Word32, Word32, Word32, Word32)
 type XYZ = (Word32, Word32, Word32)
--- a/WASH/Utility/Shell.hs
+++ b/WASH/Utility/Shell.hs
@@ -2,7 +2,7 @@
 -- |Defines functions for shell quotation.
 module WASH.Utility.Shell where

-import Char
+import Data.Char (isPrint)

 -- |Shell meta characters are /! & ; \` \' \" | * ? ~ \< \> ^ ( ) [ ] true $ n r/
 metaCharacters :: String
--- a/WASH/Utility/SimpleParser.hs
+++ b/WASH/Utility/SimpleParser.hs
@@ -1,7 +1,8 @@
 -- © 2002 Peter Thiemann
 module WASH.Utility.SimpleParser where

-import Char
+import Data.Char (isPrint, isAlpha, isAlphaNum, isAscii, isDigit)
+

 -- very simple parser combinators: Parsec is too sophisticated!
 newtype Parser a b = Parser (a -> [(b, a)])
--- a/WASH/Utility/URLCoding.hs
+++ b/WASH/Utility/URLCoding.hs
@@ -2,7 +2,7 @@
 -- |Implements coding of non-alphanumeric characters in URLs and CGI-requests.
 module WASH.Utility.URLCoding (encode, decode) where

-import Char
+import Data.Char (chr, ord, isAlphaNum)
 import WASH.Utility.Hex

 -- |Perform URI encoding of a list of bytes. See
--- a/washparser/hs/WASHParser.hs
+++ b/washparser/hs/WASHParser.hs
@@ -1,6 +1,6 @@
 module WASHParser ( xmlfile, washfile ) where {
+import Data.Char (isSpace, isAlpha) ;

-import Char ;
 import Text.ParserCombinators.Parsec hiding (letter) ;
 import WASHData;
 import WASHUtil;
--- a/washparser/hs/WASHGenerator.hs
+++ b/washparser/hs/WASHGenerator.hs
@@ -1,7 +1,8 @@
 module WASHGenerator (preprocess, preprocessPIPE) where {

-import List;
-import IO;
+import Control.Exception.Base (bracket) ;
+import Data.List (isPrefixOf) ;
+import System.IO (openFile, IOMode(ReadMode,WriteMode), Handle, hClose, hPutStrLn, hGetContents) ;

 import WASHData ;
 import Text.ParserCombinators.Parsec hiding (try) ;
--- a/washparser/hs/WASHMain.hs
+++ b/washparser/hs/WASHMain.hs
@@ -2,10 +2,12 @@

 -- ghc --make WASHMain -package text -o WASHMain

-import Directory
-import IO
-import List
-import System
+import Control.Exception.Base (bracket)
+import Data.List (isSuffixOf)
+import System.Directory (doesFileExist)
+import System.Environment (getArgs, getProgName)
+import System.IO (openFile, IOMode(ReadMode), hClose, hPutStrLn, stdout, stdin, stderr) ;
+
 import WASHGenerator
 import WASHFlags

--- a/WASH/CGI/BaseCombinators.hs
+++ b/WASH/CGI/BaseCombinators.hs
@@ -9,12 +9,10 @@
   )
 --}
 where
-
-import qualified List
-import Maybe
-import Monad
-import System
-import IO
+import Control.Monad (liftM, unless)
+import Data.Maybe (listToMaybe, isNothing, fromJust)
+import System.Exit (exitWith, ExitCode(ExitSuccess))
+import System.IO (hClose, IOMode(WriteMode), openFile)

 import WASH.Utility.Auxiliary
 import qualified WASH.Utility.Base64 as Base64
--- a/WASH/CGI/CGIConfig.hs
+++ b/WASH/CGI/CGIConfig.hs
@@ -1,8 +1,8 @@
 -- © 2002 Peter Thiemann
 module WASH.CGI.CGIConfig where

+import System.Environment (getEnv)
 import System.IO.Unsafe
-import System

 tmpDir, varDir, imageDir, emailTmpDir, frameDir, persistentDir, persistent2Dir, registryDir, keyFile, pbmPath, catProgram, sendmailProgram :: String

--- a/WASH/CGI/CGIGraphics.hs
+++ b/WASH/CGI/CGIGraphics.hs
@@ -12,10 +12,9 @@
   ,storeDirectory
   ,Pixel, CGIImage, ActionFun)
   where
-
-import Maybe
-import Monad
-import System
+import Control.Monad (liftM)
+import Data.Maybe (fromMaybe, isJust)
+import System.Cmd (system)

 import WASH.Utility.Hex
 import qualified WASH.CGI.RawCGIInternal as RawCGI
--- a/WASH/CGI/CGIHistory.hs
+++ b/WASH/CGI/CGIHistory.hs
@@ -2,12 +2,12 @@

 import System.IO.Unsafe (unsafePerformIO)

-import IO
-import Maybe
-import Monad
 import Control.Concurrent
 import Control.Concurrent.MVar
+import Control.Monad (when)
+import Data.Maybe (fromMaybe)
 import qualified Data.Map as Map
+import System.IO (Handle)
 --
 import WASH.Utility.SHA1
 import WASH.CGI.RawCGITypes
--- a/WASH/CGI/CGIInternals.hs
+++ b/WASH/CGI/CGIInternals.hs
@@ -12,11 +12,9 @@

 import Prelude hiding (head,div,span)
 import qualified Prelude
-import qualified List
-import Maybe
-import Monad
-import System
-import IO
+import Control.Monad (when, unless, mplus, liftM2)
+import Data.Maybe (fromMaybe, fromJust, isJust, maybeToList)
+import qualified Data.List as List

 import WASH.Utility.Auxiliary
 import qualified WASH.Utility.Base64 as Base64
--- a/WASH/CGI/CGIMonad.hs
+++ b/WASH/CGI/CGIMonad.hs
@@ -4,9 +4,8 @@
 module WASH.CGI.CGIMonad
 where

-import Maybe
-
 import Control.Monad.Fix
+import Data.Maybe (listToMaybe)

 import WASH.CGI.CGITypes
 import WASH.HTML.HTMLMonad hiding (span, map, div, head)
--- a/WASH/CGI/CGIOutput.hs
+++ b/WASH/CGI/CGIOutput.hs
@@ -2,11 +2,10 @@
 -- |Defines the class 'CGIOutput' of data types that can be output from a CGI
 -- program.
 module WASH.CGI.CGIOutput where
-
-import IO
-import Maybe
-import Monad
-import System
+import Control.Monad (when)
+import Data.Maybe (fromJust)
+import System.Exit (exitWith, ExitCode(ExitSuccess))
+import System.IO (hPutStr, hPutStrLn, hClose, IOMode(ReadMode), openFile, hFlush, Handle)

 import WASH.Utility.Auxiliary
 import WASH.Utility.BulkIO (rawHandleCopy)
--- a/WASH/CGI/Cookie.hs
+++ b/WASH/CGI/Cookie.hs
@@ -3,11 +3,11 @@
 -- i.e., there is a different cookie for each name and type.
 module WASH.CGI.Cookie (T, check, create, createExpiring, init, initExpiring, get, set, current, delete) where

-import Locale
-import Maybe
 import Prelude hiding (init)
-import Random
-import Time
+import Data.Maybe (fromJust)
+import System.Random (randomIO)
+import System.Locale (defaultTimeLocale)
+import System.Time (getClockTime, addToClockTime, TimeDiff(..), formatCalendarTime, toUTCTime)

 import WASH.CGI.BaseCombinators
 import WASH.CGI.CGIMonad
--- a/WASH/CGI/CookieIO.hs
+++ b/WASH/CGI/CookieIO.hs
@@ -1,6 +1,6 @@
 module WASH.CGI.CookieIO (decodeCookie, encodeCookie, putCookies) where

-import IO
+import System.IO (hPutStr, Handle)

 import WASH.CGI.CGIMonad
 import qualified WASH.CGI.Debug as Debug
--- a/WASH/CGI/Debug.hs
+++ b/WASH/CGI/Debug.hs
@@ -1,12 +1,10 @@
 module WASH.CGI.Debug where

-import Directory
-import IO
-import Monad
-import System
-import Time
-
+import Control.Monad (when)
+import System.Directory (doesDirectoryExist)
+import System.IO (Handle, openFile, IOMode(AppendMode), hClose, hPutStr, hPutStrLn, hPutChar)
 import System.IO.Unsafe
+import System.Time (getClockTime, diffClockTimes, TimeDiff(..))

 import WASH.Utility.Auxiliary
 import WASH.CGI.RawCGITypes
--- a/WASH/CGI/Persistent2.hs
+++ b/WASH/CGI/Persistent2.hs
@@ -10,19 +10,14 @@
 -}

 module WASH.CGI.Persistent2 (T, init, get, set, add, current) where
+import Data.List (find)
+import Data.Maybe (fromJust)
+import System.Random (randomIO)

 import WASH.CGI.CGIConfig

-import System
 import Prelude hiding (init)
-import qualified Prelude (init)
-import List hiding (init)
-import qualified List (init)
-import Maybe
-import IO
-import Directory
-import Monad
-import Random
+import qualified Data.List as List

 import WASH.Utility.Auxiliary
 import WASH.CGI.CGI hiding (head, div, span, map)
--- a/WASH/CGI/RawCGITypes.hs
+++ b/WASH/CGI/RawCGITypes.hs
@@ -2,8 +2,7 @@
 -- | Low-level types for raw CGI programming.

 module WASH.CGI.RawCGITypes where
-
-import IO
+import System.IO (Handle)

 import WASH.CGI.CGITypes
 import WASH.CGI.HTTP
--- a/WASH/CGI/Style.hs
+++ b/WASH/CGI/Style.hs
@@ -1,8 +1,8 @@
 -- © 2002 Peter Thiemann
 module WASH.CGI.Style (Style(..), using) where

+import Data.List (intersperse)
 import WASH.HTML.HTMLMonad hiding (map, div, head, span)
-import List

 infixl 5 :^:
 infix 9 :=:
--- a/WASH/CGI/Submit98.hs
+++ b/WASH/CGI/Submit98.hs
@@ -13,6 +13,7 @@
	, activate
	)
	where
+import Control.Monad (when)

 import WASH.CGI.AbstractSelector
 import WASH.CGI.CGIInternals
@@ -21,8 +22,6 @@
 import qualified WASH.CGI.HTMLWrapper as H
 import WASH.CGI.InputHandle

-import Monad
-
 instance HasValue InputField where
   value inf = valueInputField inf

--- a/WASH/CGI/SubmitXX.hs
+++ b/WASH/CGI/SubmitXX.hs
@@ -2,13 +2,12 @@
 -- © 2002-2005 Peter Thiemann
 -- |Extended-Haskell version of the submission functions.
 module WASH.CGI.SubmitXX where
+import Control.Monad (when)

 import WASH.CGI.CGIInternals
 import WASH.CGI.CGIMonad
 import WASH.CGI.EventHandlers

-import Monad
-
 class StripHandle hx x | hx -> x where
   validate :: hx -> Either [ValidationError] x
   isBound :: hx -> Bool
--- a/WASH/CGI/Transaction.hs
+++ b/WASH/CGI/Transaction.hs
@@ -11,6 +11,10 @@
   with, Control (..),
   TCGI ()
   ) where
+import Control.Monad (when, unless)
+import Control.OldException (try)
+import Data.Maybe (isNothing)
+import System.Directory (doesFileExist, removeFile)

 import qualified WASH.CGI.BaseCombinators as B
 import qualified WASH.CGI.CGIConfig as Conf
@@ -30,11 +34,7 @@
 import qualified WASH.Utility.Locking as L
 import qualified WASH.Utility.Unique as Unique

-import Directory
-import IO
-import qualified List
-import Maybe
-import Monad
+import qualified Data.List as List
 import Prelude hiding (init)

 transactionLock = Conf.transactionDir
--- a/WASH/CGI/TransactionUtil.hs
+++ b/WASH/CGI/TransactionUtil.hs
@@ -4,6 +4,8 @@
 module WASH.CGI.TransactionUtil
   (withCGI, withTCGI, Control (..))
   where
+import Control.Exception (try)
+import System.IO.Error (ioeGetErrorString)

 import qualified WASH.CGI.BaseCombinators as B
 import qualified WASH.CGI.HTMLWrapper as H hiding (map,head)
@@ -11,8 +13,6 @@
 import WASH.CGI.CGIMonad
 import WASH.CGI.LogEntry

-import IO
-
 import WASH.CGI.TCGI

 -- | Checks presence of a transaction mark on the stack
--- a/WASH/CGI/Types.hs
+++ b/WASH/CGI/Types.hs
@@ -21,7 +21,7 @@
 -}
 module WASH.CGI.Types where

-import Maybe
+import Data.Maybe (fromJust)

 -- | A type specification consists of a type representation 'TyRep' and a list of
 -- type declarations.
--- a/WASH/HTML/HTMLTemplates.hs
+++ b/WASH/HTML/HTMLTemplates.hs
@@ -1,12 +1,12 @@
 module WASH.HTML.HTMLTemplates where
+import Data.List ((\\))

 import WASH.HTML.HTMLBase
 import WASH.Utility.SHA1
 import WASH.Utility.JavaScript
 import qualified WASH.Utility.Base32 as Base32

-import Monad (unless)
-import List ((\\))
+import Control.Monad (unless)

 data ST s a =  ST { unST :: s -> (a, s) }
 instance Monad (ST s) where
--- a/WASH/Mail/Email.hs
+++ b/WASH/Mail/Email.hs
@@ -4,8 +4,9 @@
	module WASH.Mail.MIME, module WASH.Mail.HeaderField) where

 -- from standard library
-import IO
-import System
+import System.Cmd (system)
+import System.Exit (ExitCode(ExitSuccess, ExitFailure))
+import System.IO (openFile, hClose, IOMode(WriteMode))

 -- from utility
 import WASH.Utility.Auxiliary
--- a/WASH/Utility/Auxiliary.hs
+++ b/WASH/Utility/Auxiliary.hs
@@ -1,8 +1,11 @@
 module WASH.Utility.Auxiliary where

-import IO
-import System
-import Directory
+import System.Cmd (system)
+import System.Directory (createDirectory, doesFileExist)
+import System.Environment (getEnv)
+import System.IO (openFile, IOMode(ReadMode), hGetContents, hClose, hPutStrLn, stderr)
+import System.IO.Error (isAlreadyExistsError, isDoesNotExistError)
+
 import WASH.Utility.FileNames
 import qualified WASH.Utility.Shell as Shell

--- a/WASH/Utility/BulkIO.hs
+++ b/WASH/Utility/BulkIO.hs
@@ -1,12 +1,10 @@
 module WASH.Utility.BulkIO where

-import IO
-
-import Ptr
-import CString
-import CTypes
+import Foreign.Ptr (Ptr)
+import Foreign.C.String (peekCStringLen)
+import Foreign.C.Types (CChar)
 import Foreign.Marshal.Alloc (mallocBytes, free)
-import System.IO (hGetBuf, hPutBuf)
+import System.IO (hGetBuf, hPutBuf, Handle)

 rawGetBytes :: Handle -> Int -> IO String
 rawGetBytes h n =
--- a/WASH/Utility/Unique.hs
+++ b/WASH/Utility/Unique.hs
@@ -1,12 +1,13 @@
 -- © 2001 Peter Thiemann
 module WASH.Utility.Unique (inventStdKey, inventKey, inventFilePath) where

-import Random
-import IO
-import Directory
+import System.Cmd (system)
+import System.Directory (createDirectory, setPermissions, setOwnerReadable, setOwnerWritable, setOwnerExecutable, setOwnerSearchable, emptyPermissions)
+import System.IO (hPutStrLn, stderr)
+import System.IO.Error (isAlreadyExistsError, isDoesNotExistError)
+import System.Random (newStdGen, randomRs)
+
 import WASH.Utility.Auxiliary
-import List
-import Monad
 import WASH.Utility.Locking

 registryDir = "/tmp/Unique/"
@@ -31,7 +32,7 @@
	      inventKey len chars
	   else if isDoesNotExistError ioe then
	     do assertDirectoryExists registryDir (return ())
-		setPermissions registryDir (Permissions True True True True)
+		setPermissions registryDir ((setOwnerReadable True . setOwnerWritable True . setOwnerExecutable True . setOwnerSearchable True) emptyPermissions)
		inventKey len chars
	   else do hPutStrLn stderr ("inventKey could not create " ++ show dirname)
		   ioError ioe)
--- a/WASH/Utility/Locking.hs
+++ b/WASH/Utility/Locking.hs
@@ -4,12 +4,12 @@
 way to do it through Haskell's standard IO library.
 -}
 module WASH.Utility.Locking (obtainLock, releaseLock) where
+import System.Cmd (system)
+import System.Directory (doesDirectoryExist)

 import WASH.Utility.Auxiliary
-import Directory
-import IO
-import System
-import Time
+import System.Directory (getModificationTime, removeDirectory)
+import System.Time (getClockTime, diffClockTimes, tdSec)

 obtainLock  :: FilePath -> IO ()
 releaseLock :: FilePath -> IO ()
