From 3f6252d7c312f68e5023a6c575bdfb76fc6ad19d Mon Sep 17 00:00:00 2001
From: Myron Wu <myronwu@gmail.com>
Date: Wed, 15 Nov 2017 19:16:28 -0800
Subject: [PATCH] Bumping hoauth2 to 1.3.0 && < 1.6 to catch up with nix and
 other curated package sets

---
 gitit.cabal                                |    3 +-
 src/Network/Gitit/Authentication/Github.hs |   39 +++++++++++++++++------------
 src/Network/Gitit/Config.hs                |   26 ++++++++++++-------
 3 files changed, 42 insertions(+), 26 deletions(-)

Index: b/gitit.cabal
===================================================================
--- a/gitit.cabal
+++ b/gitit.cabal
@@ -159,8 +159,9 @@ Library
                      blaze-html >= 0.4 && < 0.10,
                      json >= 0.4 && < 0.10,
                      uri >= 0.1 && < 0.2,
+                     uri-bytestring >= 0.2.3.3 && <= 0.4,
                      split,
-                     hoauth2 >= 0.4.2 && < 0.6,
+                     hoauth2 >= 1.3.0 && < 1.6,
                      http-conduit >= 2.1.4 && < 2.3,
                      http-client-tls >= 0.2.2 && < 0.4,
                      aeson >= 0.7 && < 1.2,
Index: b/src/Network/Gitit/Authentication/Github.hs
===================================================================
--- a/src/Network/Gitit/Authentication/Github.hs
+++ b/src/Network/Gitit/Authentication/Github.hs
@@ -12,9 +12,10 @@ import Network.Gitit.Server
 import Network.Gitit.State
 import qualified Data.ByteString.Char8 as BS
 import qualified Data.ByteString.Lazy as BSL
+import qualified URI.ByteString as URI
 import Network.HTTP.Conduit
-import Network.HTTP.Client.TLS
 import Network.OAuth.OAuth2
+import Network.OAuth.OAuth2.TokenRequest as OA
 import Control.Monad (liftM, mplus, mzero)
 import Data.Maybe
 import Data.Aeson
@@ -35,8 +36,8 @@ loginGithubUser githubKey = do
   addCookie (MaxAge $ sessionTimeout cfg) (mkCookie "sid" (show key))
   let usingOrg = isJust $ org $ githubAuth cfg
   let scopes = "user:email" ++ if usingOrg then ",read:org" else ""
-  let url = authorizationUrl githubKey `appendQueryParam` [("state", BS.pack state), ("scope", BS.pack scopes)]
-  seeOther (BS.unpack url) $ toResponse ("redirecting to github" :: String)
+  let url = appendQueryParams [("state", BS.pack state), ("scope", BS.pack scopes)] $ authorizationUrl githubKey
+  seeOther (BS.unpack (URI.serializeURIRef' url)) $ toResponse ("redirecting to github" :: String)
 
 data GithubLoginError = GithubLoginError { ghUserMessage :: String
                                          , ghDetails :: Maybe String
@@ -57,13 +58,13 @@ getGithubUser ghConfig githubCallbackPar
                 let (Just code) = rCode githubCallbackPars
                 ifSuccess
                    "No access token found yet"
-                   (fetchAccessToken mgr (oAuth2 ghConfig) (sToBS code))
+                   (fetchAccessToken mgr (oAuth2 ghConfig) (ExchangeToken $ pack code))
                    (\at -> ifSuccess
                            "User Authentication failed"
-                           (userInfo mgr at)
+                           (userInfo mgr (accessToken at))
                            (\githubUser -> ifSuccess
                             ("No email for user " ++ unpack (gLogin githubUser) ++ " returned by Github")
-                            (mailInfo mgr at)
+                            (mailInfo mgr (accessToken at))
                             (\githubUserMail -> do
                                        let gitLogin = gLogin githubUser
                                        user <- mkUser (unpack gitLogin)
@@ -74,7 +75,7 @@ getGithubUser ghConfig githubCallbackPar
                                              Nothing -> return $ Right user
                                              Just githuborg -> ifSuccess
                                                       ("Membership check failed: the user " ++ unpack gitLogin ++  " is required to be a member of the organization "  ++ unpack githuborg ++ ".")
-                                                      (orgInfo gitLogin githuborg mgr at)
+                                                      (orgInfo gitLogin githuborg mgr (accessToken at))
                                                       (\_ -> return $ Right user))))
               else
                 return $ Left $
@@ -97,17 +98,26 @@ instance FromData GithubCallbackPars whe
          vState <- liftM Just (look "state") `mplus` return Nothing
          return GithubCallbackPars {rCode = vCode, rState = vState}
 
-userInfo :: Manager -> AccessToken -> IO (OAuth2Result GithubUser)
-userInfo mgr token = authGetJSON mgr token "https://api.github.com/user"
+userInfo :: Manager -> AccessToken -> IO (OAuth2Result OA.Errors GithubUser)
+userInfo mgr token = authGetJSON mgr token $ githubUri "/user"
 
-mailInfo :: Manager -> AccessToken -> IO (OAuth2Result [GithubUserMail])
-mailInfo mgr token = authGetJSON mgr token "https://api.github.com/user/emails"
+mailInfo :: Manager -> AccessToken -> IO (OAuth2Result OA.Errors [GithubUserMail])
+mailInfo mgr token = authGetJSON mgr token $ githubUri "/user/emails"
 
-orgInfo  :: Text -> Text -> Manager -> AccessToken -> IO (OAuth2Result BSL.ByteString)
+orgInfo  :: Text -> Text -> Manager -> AccessToken -> IO (OAuth2Result OA.Errors BSL.ByteString)
 orgInfo gitLogin githubOrg mgr token = do
-  let url  = "https://api.github.com/orgs/" `BS.append` encodeUtf8 githubOrg `BS.append` "/members/" `BS.append` encodeUtf8 gitLogin
+  let url = githubUri $ "/orgs/" `BS.append` encodeUtf8 githubOrg `BS.append` "/members/" `BS.append` encodeUtf8 gitLogin
   authGetBS mgr token url
 
+type UriPath = BS.ByteString
+
+githubUri :: UriPath -> URI.URI
+githubUri p = URI.URI { URI.uriScheme    = URI.Scheme "https"
+                      , URI.uriAuthority = Just $ URI.Authority Nothing (URI.Host "api.github.com") Nothing
+                      , URI.uriPath      = p
+                      , URI.uriQuery     = URI.Query []
+                      , URI.uriFragment  = Nothing }
+
 data GithubUser = GithubUser { gLogin :: Text
                              } deriving (Show, Eq)
 
@@ -125,6 +135,3 @@ instance FromJSON GithubUserMail where
                            <$> o .: "email"
                            <*> o .: "primary"
     parseJSON _ = mzero
-
-sToBS :: String -> BS.ByteString
-sToBS = encodeUtf8 . pack
Index: b/src/Network/Gitit/Config.hs
===================================================================
--- a/src/Network/Gitit/Config.hs
+++ b/src/Network/Gitit/Config.hs
@@ -40,7 +40,8 @@ import Paths_gitit (getDataFileName)
 import System.FilePath ((</>))
 import Text.Pandoc hiding (MathML, WebTeX, MathJax)
 import qualified Control.Exception as E
-import Network.OAuth.OAuth2
+import Network.OAuth.OAuth2 (OAuth2(..), oauthCallback, oauthOAuthorizeEndpoint, oauthClientId, oauthClientSecret)
+import URI.ByteString (parseURI, laxURIParserOptions)
 import qualified Data.ByteString.Char8 as BS
 import Network.Gitit.Compat.Except
 import Control.Monad
@@ -253,21 +254,28 @@ extractGithubConfig ::  (Functor m, Mona
 extractGithubConfig cp = do
       cfOauthClientId <- getGithubProp "oauthClientId"
       cfOauthClientSecret <- getGithubProp "oauthClientSecret"
-      cfOauthCallback <- getGithubProp "oauthCallback"
-      cfOauthOAuthorizeEndpoint  <- getGithubProp "oauthOAuthorizeEndpoint"
-      cfOauthAccessTokenEndpoint <- getGithubProp "oauthAccessTokenEndpoint"
+      cfOauthCallback <- getUrlProp "oauthCallback"
+      cfOauthOAuthorizeEndpoint  <- getUrlProp "oauthOAuthorizeEndpoint"
+      cfOauthAccessTokenEndpoint <- getUrlProp "oauthAccessTokenEndpoint"
       cfOrg <- if hasGithubProp "github-org"
                  then fmap Just (getGithubProp "github-org")
                  else return Nothing
-      let cfgOAuth2 = OAuth2 { oauthClientId =  BS.pack cfOauthClientId
-                          , oauthClientSecret =  BS.pack cfOauthClientSecret
-                          , oauthCallback = Just $ BS.pack cfOauthCallback
-                          , oauthOAuthorizeEndpoint = BS.pack cfOauthOAuthorizeEndpoint
-                          , oauthAccessTokenEndpoint = BS.pack cfOauthAccessTokenEndpoint
+      let cfgOAuth2 = OAuth2 { oauthClientId = pack cfOauthClientId
+                          , oauthClientSecret = pack cfOauthClientSecret
+                          , oauthCallback = Just cfOauthCallback
+                          , oauthOAuthorizeEndpoint = cfOauthOAuthorizeEndpoint
+                          , oauthAccessTokenEndpoint = cfOauthAccessTokenEndpoint
                           }
       return $ githubConfig cfgOAuth2 $ fmap pack cfOrg
   where getGithubProp = get cp "Github"
         hasGithubProp = has_option cp "Github"
+        getUrlProp prop = getGithubProp prop >>= \s ->
+                            case parseURI laxURIParserOptions (BS.pack s) of
+                              Left e    -> throwError (ParseError $ "couldn't parse url " ++ s
+                                                                    ++ " from (Github/" ++ prop ++ "): "
+                                                                    ++ (show e)
+                                                      , "getUrlProp")
+                              Right uri -> return uri
 
 fromQuotedMultiline :: String -> String
 fromQuotedMultiline = unlines . map doline . lines . dropWhile (`elem` " \t\n")
